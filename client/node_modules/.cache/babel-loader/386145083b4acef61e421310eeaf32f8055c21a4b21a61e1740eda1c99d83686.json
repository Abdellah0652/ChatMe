{"ast":null,"code":"import React, { useEffect, useRef } from 'react';\nimport { deprecationAndReplacementWarning } from '../../utils/deprecationWarning';\nimport { DEFAULT_LOAD_PAGE_SCROLL_THRESHOLD } from '../../constants/limits';\n/**\n * Prevents Chrome hangups\n * See: https://stackoverflow.com/questions/47524205/random-high-content-download-time-in-chrome/47684257#47684257\n */\nconst mousewheelListener = event => {\n  if (event instanceof WheelEvent && event.deltaY === 1) {\n    event.preventDefault();\n  }\n};\n/**\n * This component serves a single purpose - load more items on scroll inside the MessageList component\n * It is not a general purpose infinite scroll controller, because:\n * 1. It is re-rendered whenever isLoading, hasNext, hasPrev changes. This can lead to scrollListener to have stale data.\n * 2. It pretends to invoke scrollListener on resize event even though this event is emitted only on window resize. It should\n * rather use ResizeObserver. But then again, it ResizeObserver would invoke a stale version of scrollListener.\n *\n * In general, the infinite scroll controller should not aim for checking the loading state and whether there is more data to load.\n * That should be controlled by the loading function.\n */\nexport const InfiniteScroll = props => {\n  const {\n    children,\n    element = 'div',\n    hasMore,\n    hasMoreNewer,\n    hasNextPage,\n    hasPreviousPage,\n    head,\n    initialLoad = true,\n    isLoading,\n    listenToScroll,\n    loader,\n    loadMore,\n    loadMoreNewer,\n    loadNextPage,\n    loadPreviousPage,\n    threshold = DEFAULT_LOAD_PAGE_SCROLL_THRESHOLD,\n    useCapture = false,\n    ...elementProps\n  } = props;\n  const loadNextPageFn = loadNextPage || loadMoreNewer;\n  const loadPreviousPageFn = loadPreviousPage || loadMore;\n  const hasNextPageFlag = hasNextPage || hasMoreNewer;\n  const hasPreviousPageFlag = hasPreviousPage || hasMore;\n  const scrollComponent = useRef();\n  const previousOffset = useRef();\n  const previousReverseOffset = useRef();\n  const scrollListenerRef = useRef();\n  scrollListenerRef.current = () => {\n    const element = scrollComponent.current;\n    if (!element || element.offsetParent === null) {\n      return;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const parentElement = element.parentElement;\n    const offset = element.scrollHeight - parentElement.scrollTop - parentElement.clientHeight;\n    const reverseOffset = parentElement.scrollTop;\n    if (listenToScroll) {\n      listenToScroll(offset, reverseOffset, threshold);\n    }\n    if (isLoading) return;\n    if (previousOffset.current === offset && previousReverseOffset.current === reverseOffset) return;\n    previousOffset.current = offset;\n    previousReverseOffset.current = reverseOffset;\n    // FIXME: this triggers loadMore call when a user types messages in thread and the scroll container expands\n    if (reverseOffset < Number(threshold) && typeof loadPreviousPageFn === 'function' && hasPreviousPageFlag) {\n      loadPreviousPageFn();\n    }\n    if (offset < Number(threshold) && typeof loadNextPageFn === 'function' && hasNextPageFlag) {\n      loadNextPageFn();\n    }\n  };\n  useEffect(() => {\n    deprecationAndReplacementWarning([[{\n      hasMoreNewer\n    }, {\n      hasNextPage\n    }], [{\n      loadMoreNewer\n    }, {\n      loadNextPage\n    }], [{\n      hasMore\n    }, {\n      hasPreviousPage\n    }], [{\n      loadMore\n    }, {\n      loadPreviousPage\n    }]], 'InfiniteScroll');\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  useEffect(() => {\n    const scrollElement = scrollComponent.current?.parentNode;\n    if (!scrollElement) return;\n    const scrollListener = () => scrollListenerRef.current?.();\n    scrollElement.addEventListener('scroll', scrollListener, useCapture);\n    scrollElement.addEventListener('resize', scrollListener, useCapture);\n    scrollListener();\n    return () => {\n      scrollElement.removeEventListener('scroll', scrollListener, useCapture);\n      scrollElement.removeEventListener('resize', scrollListener, useCapture);\n    };\n  }, [initialLoad, useCapture]);\n  useEffect(() => {\n    const scrollElement = scrollComponent.current?.parentNode;\n    if (scrollElement) {\n      scrollElement.addEventListener('wheel', mousewheelListener, {\n        passive: false\n      });\n    }\n    return () => {\n      if (scrollElement) {\n        scrollElement.removeEventListener('wheel', mousewheelListener, useCapture);\n      }\n    };\n  }, [useCapture]);\n  const attributes = {\n    ...elementProps,\n    ref: element => {\n      scrollComponent.current = element;\n    }\n  };\n  const childrenArray = [loader, children];\n  if (head) {\n    childrenArray.unshift(head);\n  }\n  return React.createElement(element, attributes, childrenArray);\n};","map":{"version":3,"names":["React","useEffect","useRef","deprecationAndReplacementWarning","DEFAULT_LOAD_PAGE_SCROLL_THRESHOLD","mousewheelListener","event","WheelEvent","deltaY","preventDefault","InfiniteScroll","props","children","element","hasMore","hasMoreNewer","hasNextPage","hasPreviousPage","head","initialLoad","isLoading","listenToScroll","loader","loadMore","loadMoreNewer","loadNextPage","loadPreviousPage","threshold","useCapture","elementProps","loadNextPageFn","loadPreviousPageFn","hasNextPageFlag","hasPreviousPageFlag","scrollComponent","previousOffset","previousReverseOffset","scrollListenerRef","current","offsetParent","parentElement","offset","scrollHeight","scrollTop","clientHeight","reverseOffset","Number","scrollElement","parentNode","scrollListener","addEventListener","removeEventListener","passive","attributes","ref","childrenArray","unshift","createElement"],"sources":["C:/Users/abdel/OneDrive/Desktop/Medical-plager/client/node_modules/stream-chat-react/dist/components/InfiniteScrollPaginator/InfiniteScroll.js"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport { deprecationAndReplacementWarning } from '../../utils/deprecationWarning';\nimport { DEFAULT_LOAD_PAGE_SCROLL_THRESHOLD } from '../../constants/limits';\n/**\n * Prevents Chrome hangups\n * See: https://stackoverflow.com/questions/47524205/random-high-content-download-time-in-chrome/47684257#47684257\n */\nconst mousewheelListener = (event) => {\n    if (event instanceof WheelEvent && event.deltaY === 1) {\n        event.preventDefault();\n    }\n};\n/**\n * This component serves a single purpose - load more items on scroll inside the MessageList component\n * It is not a general purpose infinite scroll controller, because:\n * 1. It is re-rendered whenever isLoading, hasNext, hasPrev changes. This can lead to scrollListener to have stale data.\n * 2. It pretends to invoke scrollListener on resize event even though this event is emitted only on window resize. It should\n * rather use ResizeObserver. But then again, it ResizeObserver would invoke a stale version of scrollListener.\n *\n * In general, the infinite scroll controller should not aim for checking the loading state and whether there is more data to load.\n * That should be controlled by the loading function.\n */\nexport const InfiniteScroll = (props) => {\n    const { children, element = 'div', hasMore, hasMoreNewer, hasNextPage, hasPreviousPage, head, initialLoad = true, isLoading, listenToScroll, loader, loadMore, loadMoreNewer, loadNextPage, loadPreviousPage, threshold = DEFAULT_LOAD_PAGE_SCROLL_THRESHOLD, useCapture = false, ...elementProps } = props;\n    const loadNextPageFn = loadNextPage || loadMoreNewer;\n    const loadPreviousPageFn = loadPreviousPage || loadMore;\n    const hasNextPageFlag = hasNextPage || hasMoreNewer;\n    const hasPreviousPageFlag = hasPreviousPage || hasMore;\n    const scrollComponent = useRef();\n    const previousOffset = useRef();\n    const previousReverseOffset = useRef();\n    const scrollListenerRef = useRef();\n    scrollListenerRef.current = () => {\n        const element = scrollComponent.current;\n        if (!element || element.offsetParent === null) {\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const parentElement = element.parentElement;\n        const offset = element.scrollHeight - parentElement.scrollTop - parentElement.clientHeight;\n        const reverseOffset = parentElement.scrollTop;\n        if (listenToScroll) {\n            listenToScroll(offset, reverseOffset, threshold);\n        }\n        if (isLoading)\n            return;\n        if (previousOffset.current === offset && previousReverseOffset.current === reverseOffset)\n            return;\n        previousOffset.current = offset;\n        previousReverseOffset.current = reverseOffset;\n        // FIXME: this triggers loadMore call when a user types messages in thread and the scroll container expands\n        if (reverseOffset < Number(threshold) &&\n            typeof loadPreviousPageFn === 'function' &&\n            hasPreviousPageFlag) {\n            loadPreviousPageFn();\n        }\n        if (offset < Number(threshold) && typeof loadNextPageFn === 'function' && hasNextPageFlag) {\n            loadNextPageFn();\n        }\n    };\n    useEffect(() => {\n        deprecationAndReplacementWarning([\n            [{ hasMoreNewer }, { hasNextPage }],\n            [{ loadMoreNewer }, { loadNextPage }],\n            [{ hasMore }, { hasPreviousPage }],\n            [{ loadMore }, { loadPreviousPage }],\n        ], 'InfiniteScroll');\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    useEffect(() => {\n        const scrollElement = scrollComponent.current?.parentNode;\n        if (!scrollElement)\n            return;\n        const scrollListener = () => scrollListenerRef.current?.();\n        scrollElement.addEventListener('scroll', scrollListener, useCapture);\n        scrollElement.addEventListener('resize', scrollListener, useCapture);\n        scrollListener();\n        return () => {\n            scrollElement.removeEventListener('scroll', scrollListener, useCapture);\n            scrollElement.removeEventListener('resize', scrollListener, useCapture);\n        };\n    }, [initialLoad, useCapture]);\n    useEffect(() => {\n        const scrollElement = scrollComponent.current?.parentNode;\n        if (scrollElement) {\n            scrollElement.addEventListener('wheel', mousewheelListener, { passive: false });\n        }\n        return () => {\n            if (scrollElement) {\n                scrollElement.removeEventListener('wheel', mousewheelListener, useCapture);\n            }\n        };\n    }, [useCapture]);\n    const attributes = {\n        ...elementProps,\n        ref: (element) => {\n            scrollComponent.current = element;\n        },\n    };\n    const childrenArray = [loader, children];\n    if (head) {\n        childrenArray.unshift(head);\n    }\n    return React.createElement(element, attributes, childrenArray);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}