{"ast":null,"code":"import { useEffect, useRef } from 'react';\nimport { useChannelActionContext, useChannelStateContext, useChatContext } from '../../../context';\n/**\n * Takes care of marking a channel read. The channel is read only if all the following applies:\n * 1. the message list is not rendered in a thread\n * 2. the message list is scrolled to the bottom\n * 3. the channel was not marked unread by the user\n * @param isMessageListScrolledToBottom\n * @param messageListIsThread\n * @param unreadCount\n * @param wasChannelMarkedUnread\n */\nexport const useMarkRead = ({\n  isMessageListScrolledToBottom,\n  messageListIsThread,\n  unreadCount,\n  wasMarkedUnread\n}) => {\n  const {\n    client\n  } = useChatContext('useMarkRead');\n  const {\n    markRead,\n    setChannelUnreadUiState\n  } = useChannelActionContext('useMarkRead');\n  const {\n    channel\n  } = useChannelStateContext('useMarkRead');\n  const previousRenderMessageListScrolledToBottom = useRef(isMessageListScrolledToBottom);\n  useEffect(() => {\n    const shouldMarkRead = unreadMessages => !document.hidden && !wasMarkedUnread && !messageListIsThread && isMessageListScrolledToBottom && unreadMessages > 0;\n    const onVisibilityChange = () => {\n      if (shouldMarkRead(channel.countUnread())) markRead();\n    };\n    const handleMessageNew = event => {\n      const newMessageToCurrentChannel = event.cid === channel.cid;\n      const isOwnMessage = event.user?.id && event.user.id === client.user?.id;\n      const mainChannelUpdated = !event.message?.parent_id || event.message?.show_in_channel;\n      if (isOwnMessage) return;\n      if (!isMessageListScrolledToBottom || wasMarkedUnread || document.hidden) {\n        setChannelUnreadUiState(prev => {\n          const previousUnreadCount = prev?.unread_messages ?? 0;\n          const previousLastMessage = getPreviousLastMessage(channel.state.messages, event.message);\n          return {\n            ...(prev || {}),\n            last_read: prev?.last_read ?? (previousUnreadCount === 0 && previousLastMessage?.created_at ? new Date(previousLastMessage.created_at) : new Date(0)),\n            // not having information about the last read message means the whole channel is unread,\n            unread_messages: previousUnreadCount + 1\n          };\n        });\n      } else if (newMessageToCurrentChannel && mainChannelUpdated && shouldMarkRead(channel.countUnread())) {\n        markRead();\n      }\n    };\n    client.on('message.new', handleMessageNew);\n    document.addEventListener('visibilitychange', onVisibilityChange);\n    const hasScrolledToBottom = previousRenderMessageListScrolledToBottom.current !== isMessageListScrolledToBottom && isMessageListScrolledToBottom;\n    if (hasScrolledToBottom && shouldMarkRead(channel.countUnread())) markRead();\n    previousRenderMessageListScrolledToBottom.current = isMessageListScrolledToBottom;\n    return () => {\n      client.off('message.new', handleMessageNew);\n      document.removeEventListener('visibilitychange', onVisibilityChange);\n    };\n  }, [channel, client, isMessageListScrolledToBottom, markRead, messageListIsThread, setChannelUnreadUiState, unreadCount, wasMarkedUnread]);\n};\nfunction getPreviousLastMessage(messages, newMessage) {\n  if (!newMessage) return;\n  let previousLastMessage;\n  for (let i = messages.length - 1; i >= 0; i--) {\n    const msg = messages[i];\n    if (!msg?.id) break;\n    if (msg.id !== newMessage.id) {\n      previousLastMessage = msg;\n      break;\n    }\n  }\n  return previousLastMessage;\n}","map":{"version":3,"names":["useEffect","useRef","useChannelActionContext","useChannelStateContext","useChatContext","useMarkRead","isMessageListScrolledToBottom","messageListIsThread","unreadCount","wasMarkedUnread","client","markRead","setChannelUnreadUiState","channel","previousRenderMessageListScrolledToBottom","shouldMarkRead","unreadMessages","document","hidden","onVisibilityChange","countUnread","handleMessageNew","event","newMessageToCurrentChannel","cid","isOwnMessage","user","id","mainChannelUpdated","message","parent_id","show_in_channel","prev","previousUnreadCount","unread_messages","previousLastMessage","getPreviousLastMessage","state","messages","last_read","created_at","Date","on","addEventListener","hasScrolledToBottom","current","off","removeEventListener","newMessage","i","length","msg"],"sources":["C:/Users/abdel/OneDrive/Desktop/Medical-plager/client/node_modules/stream-chat-react/dist/components/MessageList/hooks/useMarkRead.js"],"sourcesContent":["import { useEffect, useRef } from 'react';\nimport { useChannelActionContext, useChannelStateContext, useChatContext, } from '../../../context';\n/**\n * Takes care of marking a channel read. The channel is read only if all the following applies:\n * 1. the message list is not rendered in a thread\n * 2. the message list is scrolled to the bottom\n * 3. the channel was not marked unread by the user\n * @param isMessageListScrolledToBottom\n * @param messageListIsThread\n * @param unreadCount\n * @param wasChannelMarkedUnread\n */\nexport const useMarkRead = ({ isMessageListScrolledToBottom, messageListIsThread, unreadCount, wasMarkedUnread, }) => {\n    const { client } = useChatContext('useMarkRead');\n    const { markRead, setChannelUnreadUiState } = useChannelActionContext('useMarkRead');\n    const { channel } = useChannelStateContext('useMarkRead');\n    const previousRenderMessageListScrolledToBottom = useRef(isMessageListScrolledToBottom);\n    useEffect(() => {\n        const shouldMarkRead = (unreadMessages) => !document.hidden &&\n            !wasMarkedUnread &&\n            !messageListIsThread &&\n            isMessageListScrolledToBottom &&\n            unreadMessages > 0;\n        const onVisibilityChange = () => {\n            if (shouldMarkRead(channel.countUnread()))\n                markRead();\n        };\n        const handleMessageNew = (event) => {\n            const newMessageToCurrentChannel = event.cid === channel.cid;\n            const isOwnMessage = event.user?.id && event.user.id === client.user?.id;\n            const mainChannelUpdated = !event.message?.parent_id || event.message?.show_in_channel;\n            if (isOwnMessage)\n                return;\n            if (!isMessageListScrolledToBottom || wasMarkedUnread || document.hidden) {\n                setChannelUnreadUiState((prev) => {\n                    const previousUnreadCount = prev?.unread_messages ?? 0;\n                    const previousLastMessage = getPreviousLastMessage(channel.state.messages, event.message);\n                    return {\n                        ...(prev || {}),\n                        last_read: prev?.last_read ??\n                            (previousUnreadCount === 0 && previousLastMessage?.created_at\n                                ? new Date(previousLastMessage.created_at)\n                                : new Date(0)), // not having information about the last read message means the whole channel is unread,\n                        unread_messages: previousUnreadCount + 1,\n                    };\n                });\n            }\n            else if (newMessageToCurrentChannel &&\n                mainChannelUpdated &&\n                shouldMarkRead(channel.countUnread())) {\n                markRead();\n            }\n        };\n        client.on('message.new', handleMessageNew);\n        document.addEventListener('visibilitychange', onVisibilityChange);\n        const hasScrolledToBottom = previousRenderMessageListScrolledToBottom.current !== isMessageListScrolledToBottom &&\n            isMessageListScrolledToBottom;\n        if (hasScrolledToBottom && shouldMarkRead(channel.countUnread()))\n            markRead();\n        previousRenderMessageListScrolledToBottom.current = isMessageListScrolledToBottom;\n        return () => {\n            client.off('message.new', handleMessageNew);\n            document.removeEventListener('visibilitychange', onVisibilityChange);\n        };\n    }, [\n        channel,\n        client,\n        isMessageListScrolledToBottom,\n        markRead,\n        messageListIsThread,\n        setChannelUnreadUiState,\n        unreadCount,\n        wasMarkedUnread,\n    ]);\n};\nfunction getPreviousLastMessage(messages, newMessage) {\n    if (!newMessage)\n        return;\n    let previousLastMessage;\n    for (let i = messages.length - 1; i >= 0; i--) {\n        const msg = messages[i];\n        if (!msg?.id)\n            break;\n        if (msg.id !== newMessage.id) {\n            previousLastMessage = msg;\n            break;\n        }\n    }\n    return previousLastMessage;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}