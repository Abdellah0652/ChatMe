{"ast":null,"code":"import { useEffect, useRef } from 'react';\nimport { useChannelActionContext } from '../../../context/ChannelActionContext';\nimport { useChannelStateContext } from '../../../context/ChannelStateContext';\nimport { useTranslationContext } from '../../../context/TranslationContext';\nimport { LinkPreviewState } from '../types';\nexport const useSubmitHandler = (props, state, dispatch, numberOfUploads, enrichURLsController) => {\n  const {\n    clearEditingState,\n    message,\n    overrideSubmitHandler,\n    parent,\n    publishTypingEvent\n  } = props;\n  const {\n    attachments,\n    linkPreviews,\n    mentioned_users,\n    text\n  } = state;\n  const {\n    cancelURLEnrichment,\n    findAndEnqueueURLsToEnrich\n  } = enrichURLsController;\n  const {\n    channel\n  } = useChannelStateContext('useSubmitHandler');\n  const {\n    addNotification,\n    editMessage,\n    sendMessage\n  } = useChannelActionContext('useSubmitHandler');\n  const {\n    t\n  } = useTranslationContext('useSubmitHandler');\n  const textReference = useRef({\n    hasChanged: false,\n    initialText: text\n  });\n  useEffect(() => {\n    if (!textReference.current.initialText.length) {\n      textReference.current.initialText = text;\n      return;\n    }\n    textReference.current.hasChanged = text !== textReference.current.initialText;\n  }, [text]);\n  const handleSubmit = async (event, customMessageData, options) => {\n    event?.preventDefault();\n    const trimmedMessage = text.trim();\n    const isEmptyMessage = trimmedMessage === '' || trimmedMessage === '>' || trimmedMessage === '``````' || trimmedMessage === '``' || trimmedMessage === '**' || trimmedMessage === '____' || trimmedMessage === '__' || trimmedMessage === '****';\n    if (isEmptyMessage && numberOfUploads === 0 && attachments.length === 0 && !customMessageData?.poll_id) return;\n    const someAttachmentsUploading = attachments.some(att => att.localMetadata?.uploadState === 'uploading');\n    if (someAttachmentsUploading) {\n      return addNotification(t('Wait until all attachments have uploaded'), 'error');\n    }\n    const attachmentsFromUploads = attachments.filter(att => att.localMetadata?.uploadState !== 'failed' || findAndEnqueueURLsToEnrich && !att.og_scrape_url).map(localAttachment => {\n      const {\n        localMetadata: _,\n        ...attachment\n      } = localAttachment;\n      return attachment;\n    });\n    const sendOptions = {\n      ...options\n    };\n    let attachmentsFromLinkPreviews = [];\n    if (findAndEnqueueURLsToEnrich) {\n      // prevent showing link preview in MessageInput after the message has been sent\n      cancelURLEnrichment();\n      const someLinkPreviewsLoading = Array.from(linkPreviews.values()).some(linkPreview => [LinkPreviewState.QUEUED, LinkPreviewState.LOADING].includes(linkPreview.state));\n      const someLinkPreviewsDismissed = Array.from(linkPreviews.values()).some(linkPreview => linkPreview.state === LinkPreviewState.DISMISSED);\n      attachmentsFromLinkPreviews = someLinkPreviewsLoading ? [] : Array.from(linkPreviews.values()).filter(linkPreview => linkPreview.state === LinkPreviewState.LOADED && !attachmentsFromUploads.find(attFromUpload => attFromUpload.og_scrape_url === linkPreview.og_scrape_url))\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      .map(({\n        state: linkPreviewState,\n        ...ogAttachment\n      }) => ogAttachment);\n      // scraped attachments are added only if all enrich queries has completed. Otherwise, the scraping has to be done server-side.\n      sendOptions.skip_enrich_url = !someLinkPreviewsLoading && attachmentsFromLinkPreviews.length > 0 || someLinkPreviewsDismissed;\n    }\n    const newAttachments = [...attachmentsFromUploads, ...attachmentsFromLinkPreviews];\n    // Instead of checking if a user is still mentioned every time the text changes,\n    // just filter out non-mentioned users before submit, which is cheaper\n    // and allows users to easily undo any accidental deletion\n    const actualMentionedUsers = Array.from(new Set(mentioned_users.filter(({\n      id,\n      name\n    }) => text.includes(`@${id}`) || text.includes(`@${name}`))));\n    const updatedMessage = {\n      attachments: newAttachments,\n      mentioned_users: actualMentionedUsers,\n      text\n    };\n    if (message && message.type !== 'error') {\n      delete message.i18n;\n      try {\n        await editMessage({\n          ...message,\n          ...updatedMessage,\n          ...customMessageData\n        }, sendOptions);\n        clearEditingState?.();\n        dispatch({\n          type: 'clear'\n        });\n      } catch (err) {\n        addNotification(t('Edit message request failed'), 'error');\n      }\n    } else {\n      try {\n        dispatch({\n          type: 'clear'\n        });\n        if (overrideSubmitHandler) {\n          await overrideSubmitHandler({\n            ...updatedMessage,\n            parent\n          }, channel.cid, customMessageData, sendOptions);\n        } else {\n          await sendMessage({\n            ...updatedMessage,\n            parent\n          }, customMessageData, sendOptions);\n        }\n        if (publishTypingEvent) await channel.stopTyping();\n      } catch (err) {\n        dispatch({\n          getNewText: () => text,\n          type: 'setText'\n        });\n        actualMentionedUsers?.forEach(user => {\n          dispatch({\n            type: 'addMentionedUser',\n            user\n          });\n        });\n        addNotification(t('Send message request failed'), 'error');\n      }\n    }\n  };\n  return {\n    handleSubmit\n  };\n};","map":{"version":3,"names":["useEffect","useRef","useChannelActionContext","useChannelStateContext","useTranslationContext","LinkPreviewState","useSubmitHandler","props","state","dispatch","numberOfUploads","enrichURLsController","clearEditingState","message","overrideSubmitHandler","parent","publishTypingEvent","attachments","linkPreviews","mentioned_users","text","cancelURLEnrichment","findAndEnqueueURLsToEnrich","channel","addNotification","editMessage","sendMessage","t","textReference","hasChanged","initialText","current","length","handleSubmit","event","customMessageData","options","preventDefault","trimmedMessage","trim","isEmptyMessage","poll_id","someAttachmentsUploading","some","att","localMetadata","uploadState","attachmentsFromUploads","filter","og_scrape_url","map","localAttachment","_","attachment","sendOptions","attachmentsFromLinkPreviews","someLinkPreviewsLoading","Array","from","values","linkPreview","QUEUED","LOADING","includes","someLinkPreviewsDismissed","DISMISSED","LOADED","find","attFromUpload","linkPreviewState","ogAttachment","skip_enrich_url","newAttachments","actualMentionedUsers","Set","id","name","updatedMessage","type","i18n","err","cid","stopTyping","getNewText","forEach","user"],"sources":["C:/Users/abdel/OneDrive/Desktop/Medical-plager/client/node_modules/stream-chat-react/dist/components/MessageInput/hooks/useSubmitHandler.js"],"sourcesContent":["import { useEffect, useRef } from 'react';\nimport { useChannelActionContext } from '../../../context/ChannelActionContext';\nimport { useChannelStateContext } from '../../../context/ChannelStateContext';\nimport { useTranslationContext } from '../../../context/TranslationContext';\nimport { LinkPreviewState } from '../types';\nexport const useSubmitHandler = (props, state, dispatch, numberOfUploads, enrichURLsController) => {\n    const { clearEditingState, message, overrideSubmitHandler, parent, publishTypingEvent } = props;\n    const { attachments, linkPreviews, mentioned_users, text } = state;\n    const { cancelURLEnrichment, findAndEnqueueURLsToEnrich } = enrichURLsController;\n    const { channel } = useChannelStateContext('useSubmitHandler');\n    const { addNotification, editMessage, sendMessage } = useChannelActionContext('useSubmitHandler');\n    const { t } = useTranslationContext('useSubmitHandler');\n    const textReference = useRef({ hasChanged: false, initialText: text });\n    useEffect(() => {\n        if (!textReference.current.initialText.length) {\n            textReference.current.initialText = text;\n            return;\n        }\n        textReference.current.hasChanged = text !== textReference.current.initialText;\n    }, [text]);\n    const handleSubmit = async (event, customMessageData, options) => {\n        event?.preventDefault();\n        const trimmedMessage = text.trim();\n        const isEmptyMessage = trimmedMessage === '' ||\n            trimmedMessage === '>' ||\n            trimmedMessage === '``````' ||\n            trimmedMessage === '``' ||\n            trimmedMessage === '**' ||\n            trimmedMessage === '____' ||\n            trimmedMessage === '__' ||\n            trimmedMessage === '****';\n        if (isEmptyMessage &&\n            numberOfUploads === 0 &&\n            attachments.length === 0 &&\n            !customMessageData?.poll_id)\n            return;\n        const someAttachmentsUploading = attachments.some((att) => att.localMetadata?.uploadState === 'uploading');\n        if (someAttachmentsUploading) {\n            return addNotification(t('Wait until all attachments have uploaded'), 'error');\n        }\n        const attachmentsFromUploads = attachments\n            .filter((att) => att.localMetadata?.uploadState !== 'failed' ||\n            (findAndEnqueueURLsToEnrich && !att.og_scrape_url))\n            .map((localAttachment) => {\n            const { localMetadata: _, ...attachment } = localAttachment;\n            return attachment;\n        });\n        const sendOptions = { ...options };\n        let attachmentsFromLinkPreviews = [];\n        if (findAndEnqueueURLsToEnrich) {\n            // prevent showing link preview in MessageInput after the message has been sent\n            cancelURLEnrichment();\n            const someLinkPreviewsLoading = Array.from(linkPreviews.values()).some((linkPreview) => [LinkPreviewState.QUEUED, LinkPreviewState.LOADING].includes(linkPreview.state));\n            const someLinkPreviewsDismissed = Array.from(linkPreviews.values()).some((linkPreview) => linkPreview.state === LinkPreviewState.DISMISSED);\n            attachmentsFromLinkPreviews = someLinkPreviewsLoading\n                ? []\n                : Array.from(linkPreviews.values())\n                    .filter((linkPreview) => linkPreview.state === LinkPreviewState.LOADED &&\n                    !attachmentsFromUploads.find((attFromUpload) => attFromUpload.og_scrape_url === linkPreview.og_scrape_url))\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    .map(({ state: linkPreviewState, ...ogAttachment }) => ogAttachment);\n            // scraped attachments are added only if all enrich queries has completed. Otherwise, the scraping has to be done server-side.\n            sendOptions.skip_enrich_url =\n                (!someLinkPreviewsLoading && attachmentsFromLinkPreviews.length > 0) ||\n                    someLinkPreviewsDismissed;\n        }\n        const newAttachments = [...attachmentsFromUploads, ...attachmentsFromLinkPreviews];\n        // Instead of checking if a user is still mentioned every time the text changes,\n        // just filter out non-mentioned users before submit, which is cheaper\n        // and allows users to easily undo any accidental deletion\n        const actualMentionedUsers = Array.from(new Set(mentioned_users.filter(({ id, name }) => text.includes(`@${id}`) || text.includes(`@${name}`))));\n        const updatedMessage = {\n            attachments: newAttachments,\n            mentioned_users: actualMentionedUsers,\n            text,\n        };\n        if (message && message.type !== 'error') {\n            delete message.i18n;\n            try {\n                await editMessage({\n                    ...message,\n                    ...updatedMessage,\n                    ...customMessageData,\n                }, sendOptions);\n                clearEditingState?.();\n                dispatch({ type: 'clear' });\n            }\n            catch (err) {\n                addNotification(t('Edit message request failed'), 'error');\n            }\n        }\n        else {\n            try {\n                dispatch({ type: 'clear' });\n                if (overrideSubmitHandler) {\n                    await overrideSubmitHandler({\n                        ...updatedMessage,\n                        parent,\n                    }, channel.cid, customMessageData, sendOptions);\n                }\n                else {\n                    await sendMessage({\n                        ...updatedMessage,\n                        parent,\n                    }, customMessageData, sendOptions);\n                }\n                if (publishTypingEvent)\n                    await channel.stopTyping();\n            }\n            catch (err) {\n                dispatch({\n                    getNewText: () => text,\n                    type: 'setText',\n                });\n                actualMentionedUsers?.forEach((user) => {\n                    dispatch({ type: 'addMentionedUser', user });\n                });\n                addNotification(t('Send message request failed'), 'error');\n            }\n        }\n    };\n    return { handleSubmit };\n};\n"],"mappings":"AAAA,SAASA,SAAS,EAAEC,MAAM,QAAQ,OAAO;AACzC,SAASC,uBAAuB,QAAQ,uCAAuC;AAC/E,SAASC,sBAAsB,QAAQ,sCAAsC;AAC7E,SAASC,qBAAqB,QAAQ,qCAAqC;AAC3E,SAASC,gBAAgB,QAAQ,UAAU;AAC3C,OAAO,MAAMC,gBAAgB,GAAGA,CAACC,KAAK,EAAEC,KAAK,EAAEC,QAAQ,EAAEC,eAAe,EAAEC,oBAAoB,KAAK;EAC/F,MAAM;IAAEC,iBAAiB;IAAEC,OAAO;IAAEC,qBAAqB;IAAEC,MAAM;IAAEC;EAAmB,CAAC,GAAGT,KAAK;EAC/F,MAAM;IAAEU,WAAW;IAAEC,YAAY;IAAEC,eAAe;IAAEC;EAAK,CAAC,GAAGZ,KAAK;EAClE,MAAM;IAAEa,mBAAmB;IAAEC;EAA2B,CAAC,GAAGX,oBAAoB;EAChF,MAAM;IAAEY;EAAQ,CAAC,GAAGpB,sBAAsB,CAAC,kBAAkB,CAAC;EAC9D,MAAM;IAAEqB,eAAe;IAAEC,WAAW;IAAEC;EAAY,CAAC,GAAGxB,uBAAuB,CAAC,kBAAkB,CAAC;EACjG,MAAM;IAAEyB;EAAE,CAAC,GAAGvB,qBAAqB,CAAC,kBAAkB,CAAC;EACvD,MAAMwB,aAAa,GAAG3B,MAAM,CAAC;IAAE4B,UAAU,EAAE,KAAK;IAAEC,WAAW,EAAEV;EAAK,CAAC,CAAC;EACtEpB,SAAS,CAAC,MAAM;IACZ,IAAI,CAAC4B,aAAa,CAACG,OAAO,CAACD,WAAW,CAACE,MAAM,EAAE;MAC3CJ,aAAa,CAACG,OAAO,CAACD,WAAW,GAAGV,IAAI;MACxC;IACJ;IACAQ,aAAa,CAACG,OAAO,CAACF,UAAU,GAAGT,IAAI,KAAKQ,aAAa,CAACG,OAAO,CAACD,WAAW;EACjF,CAAC,EAAE,CAACV,IAAI,CAAC,CAAC;EACV,MAAMa,YAAY,GAAG,MAAAA,CAAOC,KAAK,EAAEC,iBAAiB,EAAEC,OAAO,KAAK;IAC9DF,KAAK,EAAEG,cAAc,CAAC,CAAC;IACvB,MAAMC,cAAc,GAAGlB,IAAI,CAACmB,IAAI,CAAC,CAAC;IAClC,MAAMC,cAAc,GAAGF,cAAc,KAAK,EAAE,IACxCA,cAAc,KAAK,GAAG,IACtBA,cAAc,KAAK,QAAQ,IAC3BA,cAAc,KAAK,IAAI,IACvBA,cAAc,KAAK,IAAI,IACvBA,cAAc,KAAK,MAAM,IACzBA,cAAc,KAAK,IAAI,IACvBA,cAAc,KAAK,MAAM;IAC7B,IAAIE,cAAc,IACd9B,eAAe,KAAK,CAAC,IACrBO,WAAW,CAACe,MAAM,KAAK,CAAC,IACxB,CAACG,iBAAiB,EAAEM,OAAO,EAC3B;IACJ,MAAMC,wBAAwB,GAAGzB,WAAW,CAAC0B,IAAI,CAAEC,GAAG,IAAKA,GAAG,CAACC,aAAa,EAAEC,WAAW,KAAK,WAAW,CAAC;IAC1G,IAAIJ,wBAAwB,EAAE;MAC1B,OAAOlB,eAAe,CAACG,CAAC,CAAC,0CAA0C,CAAC,EAAE,OAAO,CAAC;IAClF;IACA,MAAMoB,sBAAsB,GAAG9B,WAAW,CACrC+B,MAAM,CAAEJ,GAAG,IAAKA,GAAG,CAACC,aAAa,EAAEC,WAAW,KAAK,QAAQ,IAC3DxB,0BAA0B,IAAI,CAACsB,GAAG,CAACK,aAAc,CAAC,CAClDC,GAAG,CAAEC,eAAe,IAAK;MAC1B,MAAM;QAAEN,aAAa,EAAEO,CAAC;QAAE,GAAGC;MAAW,CAAC,GAAGF,eAAe;MAC3D,OAAOE,UAAU;IACrB,CAAC,CAAC;IACF,MAAMC,WAAW,GAAG;MAAE,GAAGlB;IAAQ,CAAC;IAClC,IAAImB,2BAA2B,GAAG,EAAE;IACpC,IAAIjC,0BAA0B,EAAE;MAC5B;MACAD,mBAAmB,CAAC,CAAC;MACrB,MAAMmC,uBAAuB,GAAGC,KAAK,CAACC,IAAI,CAACxC,YAAY,CAACyC,MAAM,CAAC,CAAC,CAAC,CAAChB,IAAI,CAAEiB,WAAW,IAAK,CAACvD,gBAAgB,CAACwD,MAAM,EAAExD,gBAAgB,CAACyD,OAAO,CAAC,CAACC,QAAQ,CAACH,WAAW,CAACpD,KAAK,CAAC,CAAC;MACxK,MAAMwD,yBAAyB,GAAGP,KAAK,CAACC,IAAI,CAACxC,YAAY,CAACyC,MAAM,CAAC,CAAC,CAAC,CAAChB,IAAI,CAAEiB,WAAW,IAAKA,WAAW,CAACpD,KAAK,KAAKH,gBAAgB,CAAC4D,SAAS,CAAC;MAC3IV,2BAA2B,GAAGC,uBAAuB,GAC/C,EAAE,GACFC,KAAK,CAACC,IAAI,CAACxC,YAAY,CAACyC,MAAM,CAAC,CAAC,CAAC,CAC9BX,MAAM,CAAEY,WAAW,IAAKA,WAAW,CAACpD,KAAK,KAAKH,gBAAgB,CAAC6D,MAAM,IACtE,CAACnB,sBAAsB,CAACoB,IAAI,CAAEC,aAAa,IAAKA,aAAa,CAACnB,aAAa,KAAKW,WAAW,CAACX,aAAa,CAAC;MAC1G;MAAA,CACCC,GAAG,CAAC,CAAC;QAAE1C,KAAK,EAAE6D,gBAAgB;QAAE,GAAGC;MAAa,CAAC,KAAKA,YAAY,CAAC;MAC5E;MACAhB,WAAW,CAACiB,eAAe,GACtB,CAACf,uBAAuB,IAAID,2BAA2B,CAACvB,MAAM,GAAG,CAAC,IAC/DgC,yBAAyB;IACrC;IACA,MAAMQ,cAAc,GAAG,CAAC,GAAGzB,sBAAsB,EAAE,GAAGQ,2BAA2B,CAAC;IAClF;IACA;IACA;IACA,MAAMkB,oBAAoB,GAAGhB,KAAK,CAACC,IAAI,CAAC,IAAIgB,GAAG,CAACvD,eAAe,CAAC6B,MAAM,CAAC,CAAC;MAAE2B,EAAE;MAAEC;IAAK,CAAC,KAAKxD,IAAI,CAAC2C,QAAQ,CAAC,IAAIY,EAAE,EAAE,CAAC,IAAIvD,IAAI,CAAC2C,QAAQ,CAAC,IAAIa,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;IAChJ,MAAMC,cAAc,GAAG;MACnB5D,WAAW,EAAEuD,cAAc;MAC3BrD,eAAe,EAAEsD,oBAAoB;MACrCrD;IACJ,CAAC;IACD,IAAIP,OAAO,IAAIA,OAAO,CAACiE,IAAI,KAAK,OAAO,EAAE;MACrC,OAAOjE,OAAO,CAACkE,IAAI;MACnB,IAAI;QACA,MAAMtD,WAAW,CAAC;UACd,GAAGZ,OAAO;UACV,GAAGgE,cAAc;UACjB,GAAG1C;QACP,CAAC,EAAEmB,WAAW,CAAC;QACf1C,iBAAiB,GAAG,CAAC;QACrBH,QAAQ,CAAC;UAAEqE,IAAI,EAAE;QAAQ,CAAC,CAAC;MAC/B,CAAC,CACD,OAAOE,GAAG,EAAE;QACRxD,eAAe,CAACG,CAAC,CAAC,6BAA6B,CAAC,EAAE,OAAO,CAAC;MAC9D;IACJ,CAAC,MACI;MACD,IAAI;QACAlB,QAAQ,CAAC;UAAEqE,IAAI,EAAE;QAAQ,CAAC,CAAC;QAC3B,IAAIhE,qBAAqB,EAAE;UACvB,MAAMA,qBAAqB,CAAC;YACxB,GAAG+D,cAAc;YACjB9D;UACJ,CAAC,EAAEQ,OAAO,CAAC0D,GAAG,EAAE9C,iBAAiB,EAAEmB,WAAW,CAAC;QACnD,CAAC,MACI;UACD,MAAM5B,WAAW,CAAC;YACd,GAAGmD,cAAc;YACjB9D;UACJ,CAAC,EAAEoB,iBAAiB,EAAEmB,WAAW,CAAC;QACtC;QACA,IAAItC,kBAAkB,EAClB,MAAMO,OAAO,CAAC2D,UAAU,CAAC,CAAC;MAClC,CAAC,CACD,OAAOF,GAAG,EAAE;QACRvE,QAAQ,CAAC;UACL0E,UAAU,EAAEA,CAAA,KAAM/D,IAAI;UACtB0D,IAAI,EAAE;QACV,CAAC,CAAC;QACFL,oBAAoB,EAAEW,OAAO,CAAEC,IAAI,IAAK;UACpC5E,QAAQ,CAAC;YAAEqE,IAAI,EAAE,kBAAkB;YAAEO;UAAK,CAAC,CAAC;QAChD,CAAC,CAAC;QACF7D,eAAe,CAACG,CAAC,CAAC,6BAA6B,CAAC,EAAE,OAAO,CAAC;MAC9D;IACJ;EACJ,CAAC;EACD,OAAO;IAAEM;EAAa,CAAC;AAC3B,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}