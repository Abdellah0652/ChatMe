{"ast":null,"code":"import fixWebmDuration from 'fix-webm-duration';\nimport { nanoid } from 'nanoid';\nimport { AmplitudeRecorder, DEFAULT_AMPLITUDE_RECORDER_CONFIG } from './AmplitudeRecorder';\nimport { BrowserPermission } from './BrowserPermission';\nimport { BehaviorSubject, Subject } from '../observable';\nimport { transcode } from '../transcode';\nimport { resampleWaveformData } from '../../Attachment';\nimport { createFileFromBlobs, getExtensionFromMimeType, getRecordedMediaTypeFromMimeType } from '../../ReactFileUtilities';\nimport { defaultTranslatorFunction } from '../../../i18n';\nimport { isSafari } from '../../../utils/browsers';\nimport { mergeDeepUndefined } from '../../../utils/mergeDeep';\nconst RECORDED_MIME_TYPE_BY_BROWSER = {\n  audio: {\n    others: 'audio/webm',\n    safari: 'audio/mp4;codecs=mp4a.40.2'\n  }\n};\nexport const DEFAULT_MEDIA_RECORDER_CONFIG = {\n  mimeType: isSafari() ? RECORDED_MIME_TYPE_BY_BROWSER.audio.safari : RECORDED_MIME_TYPE_BY_BROWSER.audio.others\n};\nexport const DEFAULT_AUDIO_TRANSCODER_CONFIG = {\n  sampleRate: 16000\n};\nconst disposeOfMediaStream = stream => {\n  if (!stream?.active) return;\n  stream.getTracks().forEach(track => {\n    track.stop();\n    stream.removeTrack(track);\n  });\n};\nconst logError = e => e && console.error('[MEDIA RECORDER ERROR]', e);\nexport var MediaRecordingState;\n(function (MediaRecordingState) {\n  MediaRecordingState[\"PAUSED\"] = \"paused\";\n  MediaRecordingState[\"RECORDING\"] = \"recording\";\n  MediaRecordingState[\"STOPPED\"] = \"stopped\";\n})(MediaRecordingState || (MediaRecordingState = {}));\nexport var RecordingAttachmentType;\n(function (RecordingAttachmentType) {\n  RecordingAttachmentType[\"VOICE_RECORDING\"] = \"voiceRecording\";\n})(RecordingAttachmentType || (RecordingAttachmentType = {}));\nexport class MediaRecorderController {\n  constructor({\n    config,\n    generateRecordingTitle,\n    t\n  } = {}) {\n    this.recordedChunkDurations = [];\n    this.recordedData = [];\n    this.recordingState = new BehaviorSubject(undefined);\n    this.recording = new BehaviorSubject(undefined);\n    this.error = new Subject();\n    this.notification = new Subject();\n    this.generateRecordingTitle = mimeType => {\n      if (this.customGenerateRecordingTitle) {\n        return this.customGenerateRecordingTitle(mimeType);\n      }\n      return `${this.mediaType}_recording_${new Date().toISOString()}.${getExtensionFromMimeType(mimeType)}`; // extension needed so that desktop Safari can play the asset\n    };\n    this.makeVoiceRecording = async () => {\n      if (this.recordingUri) URL.revokeObjectURL(this.recordingUri);\n      if (!this.recordedData.length) return;\n      const {\n        mimeType\n      } = this.mediaRecorderConfig;\n      let blob = new Blob(this.recordedData, {\n        type: mimeType\n      });\n      if (mimeType.match('audio/webm')) {\n        // The browser does not include duration metadata with the recorded blob\n        blob = await fixWebmDuration(blob, this.durationMs, {\n          logger: () => null // prevents polluting the browser console\n        });\n      }\n      if (!mimeType.match('audio/mp4')) {\n        blob = await transcode({\n          blob,\n          ...this.transcoderConfig\n        });\n      }\n      if (!blob) return;\n      this.recordingUri = URL.createObjectURL(blob);\n      const file = createFileFromBlobs({\n        blobsArray: [blob],\n        fileName: this.generateRecordingTitle(blob.type),\n        mimeType: blob.type\n      });\n      return {\n        asset_url: this.recordingUri,\n        duration: this.durationMs / 1000,\n        file_size: blob.size,\n        localMetadata: {\n          file,\n          id: nanoid()\n        },\n        mime_type: blob.type,\n        title: file.name,\n        type: RecordingAttachmentType.VOICE_RECORDING,\n        waveform_data: resampleWaveformData(this.amplitudeRecorder?.amplitudes.value ?? [], this.amplitudeRecorderConfig.sampleCount)\n      };\n    };\n    this.handleErrorEvent = e => {\n      const {\n        error\n      } = e;\n      logError(error);\n      this.error.next(error);\n      this.notification.next({\n        text: this.t('An error has occurred during recording'),\n        type: 'error'\n      });\n    };\n    this.handleDataavailableEvent = async e => {\n      if (!e.data.size) return;\n      if (this.mediaType !== 'audio') return;\n      try {\n        this.recordedData.push(e.data);\n        const recording = await this.makeVoiceRecording();\n        if (!recording) return;\n        this.signalRecordingReady?.(recording);\n        this.recording.next(recording);\n      } catch (e) {\n        logError(e);\n        this.error.next(e);\n        this.notification.next({\n          text: this.t('An error has occurred during the recording processing'),\n          type: 'error'\n        });\n      }\n    };\n    this.resetRecordingState = () => {\n      this.recordedData = [];\n      this.recording.next(undefined);\n      this.recordingState.next(undefined);\n      this.recordedChunkDurations = [];\n      this.startTime = undefined;\n    };\n    this.cleanUp = () => {\n      this.resetRecordingState();\n      if (this.recordingUri) URL.revokeObjectURL(this.recordingUri);\n      this.amplitudeRecorder?.close();\n      if (this.mediaRecorder) {\n        disposeOfMediaStream(this.mediaRecorder.stream);\n        this.mediaRecorder.removeEventListener('dataavailable', this.handleDataavailableEvent);\n        this.mediaRecorder.removeEventListener('error', this.handleErrorEvent);\n      }\n    };\n    this.start = async () => {\n      if ([MediaRecordingState.RECORDING, MediaRecordingState.PAUSED].includes(this.recordingState.value)) {\n        const error = new Error('Cannot start recording. Recording already in progress');\n        logError(error);\n        this.error.next(error);\n        return;\n      }\n      // account for requirement on iOS as per this bug report: https://bugs.webkit.org/show_bug.cgi?id=252303\n      if (!navigator.mediaDevices) {\n        const error = new Error('Media recording is not supported');\n        logError(error);\n        this.error.next(error);\n        this.notification.next({\n          text: this.t('Error starting recording'),\n          type: 'error'\n        });\n        return;\n      }\n      if (this.mediaType === 'video') {\n        const error = new Error(`Video recording is not supported. Provided MIME type: ${this.mediaRecorderConfig.mimeType}`);\n        logError(error);\n        this.error.next(error);\n        this.notification.next({\n          text: this.t('Error starting recording'),\n          type: 'error'\n        });\n        return;\n      }\n      if (!this.permission.state.value) {\n        await this.permission.check();\n      }\n      if (this.permission.state.value === 'denied') {\n        logError(new Error('Permission denied'));\n        return;\n      }\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: true\n        });\n        this.mediaRecorder = new MediaRecorder(stream, this.mediaRecorderConfig);\n        this.mediaRecorder.addEventListener('dataavailable', this.handleDataavailableEvent);\n        this.mediaRecorder.addEventListener('error', this.handleErrorEvent);\n        this.startTime = new Date().getTime();\n        this.mediaRecorder.start();\n        if (this.mediaType === 'audio' && stream) {\n          this.amplitudeRecorder = new AmplitudeRecorder({\n            config: this.amplitudeRecorderConfig,\n            stream\n          });\n          this.amplitudeRecorder.start();\n        }\n        this.recordingState.next(MediaRecordingState.RECORDING);\n      } catch (error) {\n        logError(error);\n        this.cancel();\n        this.error.next(error);\n        this.notification.next({\n          text: this.t('Error starting recording'),\n          type: 'error'\n        });\n      }\n    };\n    this.pause = () => {\n      if (this.recordingState.value !== MediaRecordingState.RECORDING) return;\n      if (this.startTime) {\n        this.recordedChunkDurations.push(new Date().getTime() - this.startTime);\n        this.startTime = undefined;\n      }\n      this.mediaRecorder?.pause();\n      this.amplitudeRecorder?.stop();\n      this.recordingState.next(MediaRecordingState.PAUSED);\n    };\n    this.resume = () => {\n      if (this.recordingState.value !== MediaRecordingState.PAUSED) return;\n      this.startTime = new Date().getTime();\n      this.mediaRecorder?.resume();\n      this.amplitudeRecorder?.start();\n      this.recordingState.next(MediaRecordingState.RECORDING);\n    };\n    this.stop = () => {\n      const recording = this.recording.value;\n      if (recording) return Promise.resolve(recording);\n      if (![MediaRecordingState.PAUSED, MediaRecordingState.RECORDING].includes(this.mediaRecorder?.state || '')) return Promise.resolve(undefined);\n      if (this.startTime) {\n        this.recordedChunkDurations.push(new Date().getTime() - this.startTime);\n        this.startTime = undefined;\n      }\n      const result = new Promise(res => {\n        this.signalRecordingReady = res;\n      });\n      this.mediaRecorder?.stop();\n      this.amplitudeRecorder?.stop();\n      this.recordingState.next(MediaRecordingState.STOPPED);\n      return result;\n    };\n    this.cancel = () => {\n      this.stop();\n      this.cleanUp();\n    };\n    this.t = t || defaultTranslatorFunction;\n    this.amplitudeRecorderConfig = mergeDeepUndefined({\n      ...config?.amplitudeRecorderConfig\n    }, DEFAULT_AMPLITUDE_RECORDER_CONFIG);\n    this.mediaRecorderConfig = mergeDeepUndefined({\n      ...config?.mediaRecorderConfig\n    }, DEFAULT_MEDIA_RECORDER_CONFIG);\n    this.transcoderConfig = mergeDeepUndefined({\n      ...config?.transcoderConfig\n    }, DEFAULT_AUDIO_TRANSCODER_CONFIG);\n    const mediaType = getRecordedMediaTypeFromMimeType(this.mediaRecorderConfig.mimeType);\n    if (!mediaType) {\n      throw new Error(`Unsupported media type (supported audio or video only). Provided mimeType: ${this.mediaRecorderConfig.mimeType}`);\n    }\n    this.mediaType = mediaType;\n    this.permission = new BrowserPermission({\n      mediaType\n    });\n    this.customGenerateRecordingTitle = generateRecordingTitle;\n  }\n  get durationMs() {\n    return this.recordedChunkDurations.reduce((acc, val) => acc + val, 0);\n  }\n}","map":{"version":3,"names":["fixWebmDuration","nanoid","AmplitudeRecorder","DEFAULT_AMPLITUDE_RECORDER_CONFIG","BrowserPermission","BehaviorSubject","Subject","transcode","resampleWaveformData","createFileFromBlobs","getExtensionFromMimeType","getRecordedMediaTypeFromMimeType","defaultTranslatorFunction","isSafari","mergeDeepUndefined","RECORDED_MIME_TYPE_BY_BROWSER","audio","others","safari","DEFAULT_MEDIA_RECORDER_CONFIG","mimeType","DEFAULT_AUDIO_TRANSCODER_CONFIG","sampleRate","disposeOfMediaStream","stream","active","getTracks","forEach","track","stop","removeTrack","logError","e","console","error","MediaRecordingState","RecordingAttachmentType","MediaRecorderController","constructor","config","generateRecordingTitle","t","recordedChunkDurations","recordedData","recordingState","undefined","recording","notification","customGenerateRecordingTitle","mediaType","Date","toISOString","makeVoiceRecording","recordingUri","URL","revokeObjectURL","length","mediaRecorderConfig","blob","Blob","type","match","durationMs","logger","transcoderConfig","createObjectURL","file","blobsArray","fileName","asset_url","duration","file_size","size","localMetadata","id","mime_type","title","name","VOICE_RECORDING","waveform_data","amplitudeRecorder","amplitudes","value","amplitudeRecorderConfig","sampleCount","handleErrorEvent","next","text","handleDataavailableEvent","data","push","signalRecordingReady","resetRecordingState","startTime","cleanUp","close","mediaRecorder","removeEventListener","start","RECORDING","PAUSED","includes","Error","navigator","mediaDevices","permission","state","check","getUserMedia","MediaRecorder","addEventListener","getTime","cancel","pause","resume","Promise","resolve","result","res","STOPPED","reduce","acc","val"],"sources":["C:/Users/abdel/OneDrive/Desktop/Medical-plager/client/node_modules/stream-chat-react/dist/components/MediaRecorder/classes/MediaRecorderController.js"],"sourcesContent":["import fixWebmDuration from 'fix-webm-duration';\nimport { nanoid } from 'nanoid';\nimport { AmplitudeRecorder, DEFAULT_AMPLITUDE_RECORDER_CONFIG, } from './AmplitudeRecorder';\nimport { BrowserPermission } from './BrowserPermission';\nimport { BehaviorSubject, Subject } from '../observable';\nimport { transcode } from '../transcode';\nimport { resampleWaveformData } from '../../Attachment';\nimport { createFileFromBlobs, getExtensionFromMimeType, getRecordedMediaTypeFromMimeType, } from '../../ReactFileUtilities';\nimport { defaultTranslatorFunction } from '../../../i18n';\nimport { isSafari } from '../../../utils/browsers';\nimport { mergeDeepUndefined } from '../../../utils/mergeDeep';\nconst RECORDED_MIME_TYPE_BY_BROWSER = {\n    audio: {\n        others: 'audio/webm',\n        safari: 'audio/mp4;codecs=mp4a.40.2',\n    },\n};\nexport const DEFAULT_MEDIA_RECORDER_CONFIG = {\n    mimeType: isSafari()\n        ? RECORDED_MIME_TYPE_BY_BROWSER.audio.safari\n        : RECORDED_MIME_TYPE_BY_BROWSER.audio.others,\n};\nexport const DEFAULT_AUDIO_TRANSCODER_CONFIG = {\n    sampleRate: 16000,\n};\nconst disposeOfMediaStream = (stream) => {\n    if (!stream?.active)\n        return;\n    stream.getTracks().forEach((track) => {\n        track.stop();\n        stream.removeTrack(track);\n    });\n};\nconst logError = (e) => e && console.error('[MEDIA RECORDER ERROR]', e);\nexport var MediaRecordingState;\n(function (MediaRecordingState) {\n    MediaRecordingState[\"PAUSED\"] = \"paused\";\n    MediaRecordingState[\"RECORDING\"] = \"recording\";\n    MediaRecordingState[\"STOPPED\"] = \"stopped\";\n})(MediaRecordingState || (MediaRecordingState = {}));\nexport var RecordingAttachmentType;\n(function (RecordingAttachmentType) {\n    RecordingAttachmentType[\"VOICE_RECORDING\"] = \"voiceRecording\";\n})(RecordingAttachmentType || (RecordingAttachmentType = {}));\nexport class MediaRecorderController {\n    constructor({ config, generateRecordingTitle, t } = {}) {\n        this.recordedChunkDurations = [];\n        this.recordedData = [];\n        this.recordingState = new BehaviorSubject(undefined);\n        this.recording = new BehaviorSubject(undefined);\n        this.error = new Subject();\n        this.notification = new Subject();\n        this.generateRecordingTitle = (mimeType) => {\n            if (this.customGenerateRecordingTitle) {\n                return this.customGenerateRecordingTitle(mimeType);\n            }\n            return `${this.mediaType}_recording_${new Date().toISOString()}.${getExtensionFromMimeType(mimeType)}`; // extension needed so that desktop Safari can play the asset\n        };\n        this.makeVoiceRecording = async () => {\n            if (this.recordingUri)\n                URL.revokeObjectURL(this.recordingUri);\n            if (!this.recordedData.length)\n                return;\n            const { mimeType } = this.mediaRecorderConfig;\n            let blob = new Blob(this.recordedData, { type: mimeType });\n            if (mimeType.match('audio/webm')) {\n                // The browser does not include duration metadata with the recorded blob\n                blob = await fixWebmDuration(blob, this.durationMs, {\n                    logger: () => null, // prevents polluting the browser console\n                });\n            }\n            if (!mimeType.match('audio/mp4')) {\n                blob = await transcode({\n                    blob,\n                    ...this.transcoderConfig,\n                });\n            }\n            if (!blob)\n                return;\n            this.recordingUri = URL.createObjectURL(blob);\n            const file = createFileFromBlobs({\n                blobsArray: [blob],\n                fileName: this.generateRecordingTitle(blob.type),\n                mimeType: blob.type,\n            });\n            return {\n                asset_url: this.recordingUri,\n                duration: this.durationMs / 1000,\n                file_size: blob.size,\n                localMetadata: {\n                    file,\n                    id: nanoid(),\n                },\n                mime_type: blob.type,\n                title: file.name,\n                type: RecordingAttachmentType.VOICE_RECORDING,\n                waveform_data: resampleWaveformData(this.amplitudeRecorder?.amplitudes.value ?? [], this.amplitudeRecorderConfig.sampleCount),\n            };\n        };\n        this.handleErrorEvent = (e) => {\n            const { error } = e;\n            logError(error);\n            this.error.next(error);\n            this.notification.next({\n                text: this.t('An error has occurred during recording'),\n                type: 'error',\n            });\n        };\n        this.handleDataavailableEvent = async (e) => {\n            if (!e.data.size)\n                return;\n            if (this.mediaType !== 'audio')\n                return;\n            try {\n                this.recordedData.push(e.data);\n                const recording = await this.makeVoiceRecording();\n                if (!recording)\n                    return;\n                this.signalRecordingReady?.(recording);\n                this.recording.next(recording);\n            }\n            catch (e) {\n                logError(e);\n                this.error.next(e);\n                this.notification.next({\n                    text: this.t('An error has occurred during the recording processing'),\n                    type: 'error',\n                });\n            }\n        };\n        this.resetRecordingState = () => {\n            this.recordedData = [];\n            this.recording.next(undefined);\n            this.recordingState.next(undefined);\n            this.recordedChunkDurations = [];\n            this.startTime = undefined;\n        };\n        this.cleanUp = () => {\n            this.resetRecordingState();\n            if (this.recordingUri)\n                URL.revokeObjectURL(this.recordingUri);\n            this.amplitudeRecorder?.close();\n            if (this.mediaRecorder) {\n                disposeOfMediaStream(this.mediaRecorder.stream);\n                this.mediaRecorder.removeEventListener('dataavailable', this.handleDataavailableEvent);\n                this.mediaRecorder.removeEventListener('error', this.handleErrorEvent);\n            }\n        };\n        this.start = async () => {\n            if ([MediaRecordingState.RECORDING, MediaRecordingState.PAUSED].includes(this.recordingState.value)) {\n                const error = new Error('Cannot start recording. Recording already in progress');\n                logError(error);\n                this.error.next(error);\n                return;\n            }\n            // account for requirement on iOS as per this bug report: https://bugs.webkit.org/show_bug.cgi?id=252303\n            if (!navigator.mediaDevices) {\n                const error = new Error('Media recording is not supported');\n                logError(error);\n                this.error.next(error);\n                this.notification.next({ text: this.t('Error starting recording'), type: 'error' });\n                return;\n            }\n            if (this.mediaType === 'video') {\n                const error = new Error(`Video recording is not supported. Provided MIME type: ${this.mediaRecorderConfig.mimeType}`);\n                logError(error);\n                this.error.next(error);\n                this.notification.next({ text: this.t('Error starting recording'), type: 'error' });\n                return;\n            }\n            if (!this.permission.state.value) {\n                await this.permission.check();\n            }\n            if (this.permission.state.value === 'denied') {\n                logError(new Error('Permission denied'));\n                return;\n            }\n            try {\n                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n                this.mediaRecorder = new MediaRecorder(stream, this.mediaRecorderConfig);\n                this.mediaRecorder.addEventListener('dataavailable', this.handleDataavailableEvent);\n                this.mediaRecorder.addEventListener('error', this.handleErrorEvent);\n                this.startTime = new Date().getTime();\n                this.mediaRecorder.start();\n                if (this.mediaType === 'audio' && stream) {\n                    this.amplitudeRecorder = new AmplitudeRecorder({\n                        config: this.amplitudeRecorderConfig,\n                        stream,\n                    });\n                    this.amplitudeRecorder.start();\n                }\n                this.recordingState.next(MediaRecordingState.RECORDING);\n            }\n            catch (error) {\n                logError(error);\n                this.cancel();\n                this.error.next(error);\n                this.notification.next({ text: this.t('Error starting recording'), type: 'error' });\n            }\n        };\n        this.pause = () => {\n            if (this.recordingState.value !== MediaRecordingState.RECORDING)\n                return;\n            if (this.startTime) {\n                this.recordedChunkDurations.push(new Date().getTime() - this.startTime);\n                this.startTime = undefined;\n            }\n            this.mediaRecorder?.pause();\n            this.amplitudeRecorder?.stop();\n            this.recordingState.next(MediaRecordingState.PAUSED);\n        };\n        this.resume = () => {\n            if (this.recordingState.value !== MediaRecordingState.PAUSED)\n                return;\n            this.startTime = new Date().getTime();\n            this.mediaRecorder?.resume();\n            this.amplitudeRecorder?.start();\n            this.recordingState.next(MediaRecordingState.RECORDING);\n        };\n        this.stop = () => {\n            const recording = this.recording.value;\n            if (recording)\n                return Promise.resolve(recording);\n            if (![MediaRecordingState.PAUSED, MediaRecordingState.RECORDING].includes((this.mediaRecorder?.state || '')))\n                return Promise.resolve(undefined);\n            if (this.startTime) {\n                this.recordedChunkDurations.push(new Date().getTime() - this.startTime);\n                this.startTime = undefined;\n            }\n            const result = new Promise((res) => {\n                this.signalRecordingReady = res;\n            });\n            this.mediaRecorder?.stop();\n            this.amplitudeRecorder?.stop();\n            this.recordingState.next(MediaRecordingState.STOPPED);\n            return result;\n        };\n        this.cancel = () => {\n            this.stop();\n            this.cleanUp();\n        };\n        this.t = t || defaultTranslatorFunction;\n        this.amplitudeRecorderConfig = mergeDeepUndefined({ ...config?.amplitudeRecorderConfig }, DEFAULT_AMPLITUDE_RECORDER_CONFIG);\n        this.mediaRecorderConfig = mergeDeepUndefined({ ...config?.mediaRecorderConfig }, DEFAULT_MEDIA_RECORDER_CONFIG);\n        this.transcoderConfig = mergeDeepUndefined({ ...config?.transcoderConfig }, DEFAULT_AUDIO_TRANSCODER_CONFIG);\n        const mediaType = getRecordedMediaTypeFromMimeType(this.mediaRecorderConfig.mimeType);\n        if (!mediaType) {\n            throw new Error(`Unsupported media type (supported audio or video only). Provided mimeType: ${this.mediaRecorderConfig.mimeType}`);\n        }\n        this.mediaType = mediaType;\n        this.permission = new BrowserPermission({ mediaType });\n        this.customGenerateRecordingTitle = generateRecordingTitle;\n    }\n    get durationMs() {\n        return this.recordedChunkDurations.reduce((acc, val) => acc + val, 0);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}