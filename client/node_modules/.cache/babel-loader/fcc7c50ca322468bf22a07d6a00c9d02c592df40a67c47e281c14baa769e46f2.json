{"ast":null,"code":"import throttle from 'lodash.throttle';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { useChannelActionContext, useTranslationContext } from '../../../context';\nconst isSeekable = audioElement => !(audioElement.duration === Infinity || isNaN(audioElement.duration));\nexport const elementIsPlaying = audioElement => audioElement && !(audioElement.paused || audioElement.ended);\nconst logError = e => console.error('[AUDIO PLAYER]', e);\nconst DEFAULT_PLAYBACK_RATES = [1.0, 1.5, 2.0];\nexport const useAudioController = ({\n  durationSeconds,\n  mimeType,\n  playbackRates = DEFAULT_PLAYBACK_RATES\n} = {}) => {\n  const {\n    addNotification\n  } = useChannelActionContext('useAudioController');\n  const {\n    t\n  } = useTranslationContext('useAudioController');\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [playbackError, setPlaybackError] = useState();\n  const [canPlayRecord, setCanPlayRecord] = useState(true);\n  const [secondsElapsed, setSecondsElapsed] = useState(0);\n  const [playbackRateIndex, setPlaybackRateIndex] = useState(0);\n  const playTimeout = useRef();\n  const audioRef = useRef(null);\n  const registerError = useCallback(e => {\n    logError(e);\n    setPlaybackError(e);\n    addNotification(e.message, 'error');\n  }, [addNotification]);\n  const togglePlay = useCallback(async () => {\n    if (!audioRef.current) return;\n    clearTimeout(playTimeout.current);\n    playTimeout.current = undefined;\n    if (mimeType && !audioRef.current.canPlayType(mimeType)) {\n      registerError(new Error(t('Recording format is not supported and cannot be reproduced')));\n      setCanPlayRecord(false);\n      return;\n    }\n    if (elementIsPlaying(audioRef.current)) {\n      audioRef.current.pause();\n      setIsPlaying(false);\n    } else {\n      playTimeout.current = setTimeout(() => {\n        if (!audioRef.current) return;\n        try {\n          audioRef.current.pause();\n          setIsPlaying(false);\n        } catch (e) {\n          registerError(new Error(t('Failed to play the recording')));\n        }\n      }, 2000);\n      try {\n        await audioRef.current.play();\n        setIsPlaying(true);\n      } catch (e) {\n        registerError(e);\n        setIsPlaying(false);\n      } finally {\n        clearTimeout(playTimeout.current);\n        playTimeout.current = undefined;\n      }\n    }\n  }, [mimeType, registerError, t]);\n  const increasePlaybackRate = () => {\n    setPlaybackRateIndex(prev => {\n      if (!audioRef.current) return prev;\n      const nextIndex = prev === playbackRates.length - 1 ? 0 : prev + 1;\n      audioRef.current.playbackRate = playbackRates[nextIndex];\n      return nextIndex;\n    });\n  };\n  const seek = useMemo(() => throttle(({\n    clientX,\n    currentTarget\n  }) => {\n    if (!(currentTarget && audioRef.current)) return;\n    if (!isSeekable(audioRef.current)) {\n      registerError(new Error(t('Cannot seek in the recording')));\n      return;\n    }\n    const {\n      width,\n      x\n    } = currentTarget.getBoundingClientRect();\n    const ratio = (clientX - x) / width;\n    if (ratio > 1 || ratio < 0) return;\n    const currentTime = ratio * audioRef.current.duration;\n    setSecondsElapsed(currentTime);\n    audioRef.current.currentTime = currentTime;\n  }, 16), [registerError, t]);\n  useEffect(() => {\n    if (!audioRef.current) return;\n    const audioElement = audioRef.current;\n    const handleEnded = () => {\n      setSecondsElapsed(audioElement?.duration ?? durationSeconds ?? 0);\n      setIsPlaying(false);\n    };\n    audioElement.addEventListener('ended', handleEnded);\n    const handleError = () => {\n      addNotification(t('Error reproducing the recording'), 'error');\n      setIsPlaying(false);\n    };\n    audioElement.addEventListener('error', handleError);\n    const handleTimeupdate = () => {\n      setSecondsElapsed(audioElement?.currentTime);\n    };\n    audioElement.addEventListener('timeupdate', handleTimeupdate);\n    return () => {\n      audioElement.pause();\n      audioElement.removeEventListener('ended', handleEnded);\n      audioElement.removeEventListener('error', handleError);\n      audioElement.removeEventListener('timeupdate', handleTimeupdate);\n    };\n  }, [addNotification, durationSeconds, t]);\n  return {\n    audioRef,\n    canPlayRecord,\n    increasePlaybackRate,\n    isPlaying,\n    playbackError,\n    playbackRate: playbackRates[playbackRateIndex],\n    progress: audioRef.current && secondsElapsed ? secondsElapsed / audioRef.current.duration * 100 : 0,\n    secondsElapsed,\n    seek,\n    togglePlay\n  };\n};","map":{"version":3,"names":["throttle","useCallback","useEffect","useMemo","useRef","useState","useChannelActionContext","useTranslationContext","isSeekable","audioElement","duration","Infinity","isNaN","elementIsPlaying","paused","ended","logError","e","console","error","DEFAULT_PLAYBACK_RATES","useAudioController","durationSeconds","mimeType","playbackRates","addNotification","t","isPlaying","setIsPlaying","playbackError","setPlaybackError","canPlayRecord","setCanPlayRecord","secondsElapsed","setSecondsElapsed","playbackRateIndex","setPlaybackRateIndex","playTimeout","audioRef","registerError","message","togglePlay","current","clearTimeout","undefined","canPlayType","Error","pause","setTimeout","play","increasePlaybackRate","prev","nextIndex","length","playbackRate","seek","clientX","currentTarget","width","x","getBoundingClientRect","ratio","currentTime","handleEnded","addEventListener","handleError","handleTimeupdate","removeEventListener","progress"],"sources":["C:/Users/abdel/OneDrive/Desktop/Medical-plager/client/node_modules/stream-chat-react/dist/components/Attachment/hooks/useAudioController.js"],"sourcesContent":["import throttle from 'lodash.throttle';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { useChannelActionContext, useTranslationContext } from '../../../context';\nconst isSeekable = (audioElement) => !(audioElement.duration === Infinity || isNaN(audioElement.duration));\nexport const elementIsPlaying = (audioElement) => audioElement && !(audioElement.paused || audioElement.ended);\nconst logError = (e) => console.error('[AUDIO PLAYER]', e);\nconst DEFAULT_PLAYBACK_RATES = [1.0, 1.5, 2.0];\nexport const useAudioController = ({ durationSeconds, mimeType, playbackRates = DEFAULT_PLAYBACK_RATES, } = {}) => {\n    const { addNotification } = useChannelActionContext('useAudioController');\n    const { t } = useTranslationContext('useAudioController');\n    const [isPlaying, setIsPlaying] = useState(false);\n    const [playbackError, setPlaybackError] = useState();\n    const [canPlayRecord, setCanPlayRecord] = useState(true);\n    const [secondsElapsed, setSecondsElapsed] = useState(0);\n    const [playbackRateIndex, setPlaybackRateIndex] = useState(0);\n    const playTimeout = useRef();\n    const audioRef = useRef(null);\n    const registerError = useCallback((e) => {\n        logError(e);\n        setPlaybackError(e);\n        addNotification(e.message, 'error');\n    }, [addNotification]);\n    const togglePlay = useCallback(async () => {\n        if (!audioRef.current)\n            return;\n        clearTimeout(playTimeout.current);\n        playTimeout.current = undefined;\n        if (mimeType && !audioRef.current.canPlayType(mimeType)) {\n            registerError(new Error(t('Recording format is not supported and cannot be reproduced')));\n            setCanPlayRecord(false);\n            return;\n        }\n        if (elementIsPlaying(audioRef.current)) {\n            audioRef.current.pause();\n            setIsPlaying(false);\n        }\n        else {\n            playTimeout.current = setTimeout(() => {\n                if (!audioRef.current)\n                    return;\n                try {\n                    audioRef.current.pause();\n                    setIsPlaying(false);\n                }\n                catch (e) {\n                    registerError(new Error(t('Failed to play the recording')));\n                }\n            }, 2000);\n            try {\n                await audioRef.current.play();\n                setIsPlaying(true);\n            }\n            catch (e) {\n                registerError(e);\n                setIsPlaying(false);\n            }\n            finally {\n                clearTimeout(playTimeout.current);\n                playTimeout.current = undefined;\n            }\n        }\n    }, [mimeType, registerError, t]);\n    const increasePlaybackRate = () => {\n        setPlaybackRateIndex((prev) => {\n            if (!audioRef.current)\n                return prev;\n            const nextIndex = prev === playbackRates.length - 1 ? 0 : prev + 1;\n            audioRef.current.playbackRate = playbackRates[nextIndex];\n            return nextIndex;\n        });\n    };\n    const seek = useMemo(() => throttle(({ clientX, currentTarget }) => {\n        if (!(currentTarget && audioRef.current))\n            return;\n        if (!isSeekable(audioRef.current)) {\n            registerError(new Error(t('Cannot seek in the recording')));\n            return;\n        }\n        const { width, x } = currentTarget.getBoundingClientRect();\n        const ratio = (clientX - x) / width;\n        if (ratio > 1 || ratio < 0)\n            return;\n        const currentTime = ratio * audioRef.current.duration;\n        setSecondsElapsed(currentTime);\n        audioRef.current.currentTime = currentTime;\n    }, 16), [registerError, t]);\n    useEffect(() => {\n        if (!audioRef.current)\n            return;\n        const audioElement = audioRef.current;\n        const handleEnded = () => {\n            setSecondsElapsed(audioElement?.duration ?? durationSeconds ?? 0);\n            setIsPlaying(false);\n        };\n        audioElement.addEventListener('ended', handleEnded);\n        const handleError = () => {\n            addNotification(t('Error reproducing the recording'), 'error');\n            setIsPlaying(false);\n        };\n        audioElement.addEventListener('error', handleError);\n        const handleTimeupdate = () => {\n            setSecondsElapsed(audioElement?.currentTime);\n        };\n        audioElement.addEventListener('timeupdate', handleTimeupdate);\n        return () => {\n            audioElement.pause();\n            audioElement.removeEventListener('ended', handleEnded);\n            audioElement.removeEventListener('error', handleError);\n            audioElement.removeEventListener('timeupdate', handleTimeupdate);\n        };\n    }, [addNotification, durationSeconds, t]);\n    return {\n        audioRef,\n        canPlayRecord,\n        increasePlaybackRate,\n        isPlaying,\n        playbackError,\n        playbackRate: playbackRates[playbackRateIndex],\n        progress: audioRef.current && secondsElapsed ? (secondsElapsed / audioRef.current.duration) * 100 : 0,\n        secondsElapsed,\n        seek,\n        togglePlay,\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}