{"ast":null,"code":"import { useCallback } from 'react';\nimport { nanoid } from 'nanoid';\nimport { checkUploadPermissions } from './utils';\nimport { isLocalAttachment, isLocalImageAttachment } from '../../Attachment';\nimport { createFileFromBlobs, generateFileName, isBlobButNotFile } from '../../ReactFileUtilities';\nimport { useChannelActionContext, useChannelStateContext, useChatContext, useTranslationContext } from '../../../context';\nconst apiMaxNumberOfFiles = 10;\n// const isAudioFile = (file: FileLike) => file.type.includes('audio/');\nconst isImageFile = file => file.type.startsWith('image/') && !file.type.endsWith('.photoshop'); // photoshop files begin with 'image/'\n// const isVideoFile = (file: FileLike) => file.type.includes('video/');\nconst getAttachmentTypeFromMime = mimeType => {\n  if (mimeType.startsWith('image/') && !mimeType.endsWith('.photoshop')) return 'image';\n  if (mimeType.includes('video/')) return 'video';\n  if (mimeType.includes('audio/')) return 'audio';\n  return 'file';\n};\nconst ensureIsLocalAttachment = attachment => {\n  if (isLocalAttachment(attachment)) {\n    return attachment;\n  }\n  const {\n    localMetadata,\n    ...rest\n  } = attachment;\n  return {\n    localMetadata: {\n      ...(localMetadata ?? {}),\n      id: localMetadata?.id || nanoid()\n    },\n    ...rest\n  };\n};\nexport const useAttachments = (props, state, dispatch, textareaRef) => {\n  const {\n    doFileUploadRequest,\n    doImageUploadRequest,\n    errorHandler,\n    noFiles\n  } = props;\n  const {\n    getAppSettings\n  } = useChatContext('useAttachments');\n  const {\n    t\n  } = useTranslationContext('useAttachments');\n  const {\n    addNotification\n  } = useChannelActionContext('useAttachments');\n  const {\n    channel,\n    maxNumberOfFiles,\n    multipleUploads\n  } = useChannelStateContext('useAttachments');\n  // Number of files that the user can still add. Should never be more than the amount allowed by the API.\n  // If multipleUploads is false, we only want to allow a single upload.\n  const maxFilesAllowed = !multipleUploads ? 1 : maxNumberOfFiles || apiMaxNumberOfFiles;\n  const numberOfUploads = Object.values(state.attachments).filter(({\n    localMetadata\n  }) => localMetadata.uploadState && localMetadata.uploadState !== 'failed').length;\n  const maxFilesLeft = maxFilesAllowed - numberOfUploads;\n  const removeAttachments = useCallback(ids => {\n    if (!ids.length) return;\n    dispatch({\n      ids,\n      type: 'removeAttachments'\n    });\n  }, [dispatch]);\n  const upsertAttachments = useCallback(attachments => {\n    if (!attachments.length) return;\n    dispatch({\n      attachments: attachments.map(ensureIsLocalAttachment),\n      type: 'upsertAttachments'\n    });\n  }, [dispatch]);\n  const uploadAttachment = useCallback(async att => {\n    const {\n      localMetadata,\n      ...providedAttachmentData\n    } = att;\n    if (!localMetadata?.file) return att;\n    const {\n      file\n    } = localMetadata;\n    const isImage = isImageFile(file);\n    if (noFiles && !isImage) return att;\n    const canUpload = await checkUploadPermissions({\n      addNotification,\n      file,\n      getAppSettings,\n      t,\n      uploadType: isImage ? 'image' : 'file'\n    });\n    if (!canUpload) return att;\n    localMetadata.id = localMetadata?.id ?? nanoid();\n    const finalAttachment = {\n      type: getAttachmentTypeFromMime(file.type)\n    };\n    if (isImage) {\n      localMetadata.previewUri = URL.createObjectURL?.(file);\n      if (file instanceof File) {\n        finalAttachment.fallback = file.name;\n      }\n    } else {\n      finalAttachment.file_size = file.size;\n      finalAttachment.mime_type = file.type;\n      if (file instanceof File) {\n        finalAttachment.title = file.name;\n      }\n    }\n    Object.assign(finalAttachment, providedAttachmentData);\n    upsertAttachments([{\n      ...finalAttachment,\n      localMetadata: {\n        ...localMetadata,\n        uploadState: 'uploading'\n      }\n    }]);\n    let response;\n    try {\n      const doUploadRequest = isImage ? doImageUploadRequest : doFileUploadRequest;\n      if (doUploadRequest) {\n        response = await doUploadRequest(file, channel);\n      } else {\n        response = await channel[isImage ? 'sendImage' : 'sendFile'](file);\n      }\n    } catch (error) {\n      let finalError = {\n        message: t('Error uploading attachment'),\n        name: 'Error'\n      };\n      if (typeof error.message === 'string') {\n        finalError = error;\n      } else if (typeof error === 'object') {\n        finalError = Object.assign(finalError, error);\n      }\n      console.error(finalError);\n      addNotification(finalError.message, 'error');\n      const failedAttachment = {\n        ...finalAttachment,\n        localMetadata: {\n          ...localMetadata,\n          uploadState: 'failed'\n        }\n      };\n      upsertAttachments([failedAttachment]);\n      if (errorHandler) {\n        errorHandler(finalError, 'upload-attachment', {\n          ...file,\n          id: localMetadata.id\n        });\n      }\n      return failedAttachment;\n    }\n    if (!response) {\n      // Copied this from useImageUpload / useFileUpload.\n      // If doUploadRequest returns any falsy value, then don't create the upload preview.\n      // This is for the case if someone wants to handle failure on app level.\n      removeAttachments([localMetadata.id]);\n      return;\n    }\n    const uploadedAttachment = {\n      ...finalAttachment,\n      localMetadata: {\n        ...localMetadata,\n        uploadState: 'finished'\n      }\n    };\n    if (isLocalImageAttachment(uploadedAttachment)) {\n      if (uploadedAttachment.localMetadata.previewUri) {\n        URL.revokeObjectURL(uploadedAttachment.localMetadata.previewUri);\n        delete uploadedAttachment.localMetadata.previewUri;\n      }\n      uploadedAttachment.image_url = response.file;\n    } else {\n      uploadedAttachment.asset_url = response.file;\n    }\n    if (response.thumb_url) {\n      uploadedAttachment.thumb_url = response.thumb_url;\n    }\n    upsertAttachments([uploadedAttachment]);\n    return uploadedAttachment;\n  }, [addNotification, channel, doFileUploadRequest, doImageUploadRequest, errorHandler, getAppSettings, noFiles, removeAttachments, t, upsertAttachments]);\n  const uploadNewFiles = useCallback(files => {\n    const filesToBeUploaded = noFiles ? Array.from(files).filter(isImageFile) : Array.from(files);\n    filesToBeUploaded.slice(0, maxFilesLeft).forEach(fileLike => {\n      uploadAttachment({\n        localMetadata: {\n          file: isBlobButNotFile(fileLike) ? createFileFromBlobs({\n            blobsArray: [fileLike],\n            fileName: generateFileName(fileLike.type),\n            mimeType: fileLike.type\n          }) : fileLike,\n          id: nanoid()\n        }\n      });\n    });\n    textareaRef.current?.focus();\n  }, [maxFilesLeft, noFiles, textareaRef, uploadAttachment]);\n  return {\n    maxFilesLeft,\n    numberOfUploads,\n    removeAttachments,\n    uploadAttachment,\n    uploadNewFiles,\n    upsertAttachments\n  };\n};","map":{"version":3,"names":["useCallback","nanoid","checkUploadPermissions","isLocalAttachment","isLocalImageAttachment","createFileFromBlobs","generateFileName","isBlobButNotFile","useChannelActionContext","useChannelStateContext","useChatContext","useTranslationContext","apiMaxNumberOfFiles","isImageFile","file","type","startsWith","endsWith","getAttachmentTypeFromMime","mimeType","includes","ensureIsLocalAttachment","attachment","localMetadata","rest","id","useAttachments","props","state","dispatch","textareaRef","doFileUploadRequest","doImageUploadRequest","errorHandler","noFiles","getAppSettings","t","addNotification","channel","maxNumberOfFiles","multipleUploads","maxFilesAllowed","numberOfUploads","Object","values","attachments","filter","uploadState","length","maxFilesLeft","removeAttachments","ids","upsertAttachments","map","uploadAttachment","att","providedAttachmentData","isImage","canUpload","uploadType","finalAttachment","previewUri","URL","createObjectURL","File","fallback","name","file_size","size","mime_type","title","assign","response","doUploadRequest","error","finalError","message","console","failedAttachment","uploadedAttachment","revokeObjectURL","image_url","asset_url","thumb_url","uploadNewFiles","files","filesToBeUploaded","Array","from","slice","forEach","fileLike","blobsArray","fileName","current","focus"],"sources":["C:/Users/abdel/OneDrive/Desktop/Medical-plager/client/node_modules/stream-chat-react/dist/components/MessageInput/hooks/useAttachments.js"],"sourcesContent":["import { useCallback } from 'react';\nimport { nanoid } from 'nanoid';\nimport { checkUploadPermissions } from './utils';\nimport { isLocalAttachment, isLocalImageAttachment } from '../../Attachment';\nimport { createFileFromBlobs, generateFileName, isBlobButNotFile } from '../../ReactFileUtilities';\nimport { useChannelActionContext, useChannelStateContext, useChatContext, useTranslationContext, } from '../../../context';\nconst apiMaxNumberOfFiles = 10;\n// const isAudioFile = (file: FileLike) => file.type.includes('audio/');\nconst isImageFile = (file) => file.type.startsWith('image/') && !file.type.endsWith('.photoshop'); // photoshop files begin with 'image/'\n// const isVideoFile = (file: FileLike) => file.type.includes('video/');\nconst getAttachmentTypeFromMime = (mimeType) => {\n    if (mimeType.startsWith('image/') && !mimeType.endsWith('.photoshop'))\n        return 'image';\n    if (mimeType.includes('video/'))\n        return 'video';\n    if (mimeType.includes('audio/'))\n        return 'audio';\n    return 'file';\n};\nconst ensureIsLocalAttachment = (attachment) => {\n    if (isLocalAttachment(attachment)) {\n        return attachment;\n    }\n    const { localMetadata, ...rest } = attachment;\n    return {\n        localMetadata: {\n            ...(localMetadata ?? {}),\n            id: localMetadata?.id || nanoid(),\n        },\n        ...rest,\n    };\n};\nexport const useAttachments = (props, state, dispatch, textareaRef) => {\n    const { doFileUploadRequest, doImageUploadRequest, errorHandler, noFiles } = props;\n    const { getAppSettings } = useChatContext('useAttachments');\n    const { t } = useTranslationContext('useAttachments');\n    const { addNotification } = useChannelActionContext('useAttachments');\n    const { channel, maxNumberOfFiles, multipleUploads } = useChannelStateContext('useAttachments');\n    // Number of files that the user can still add. Should never be more than the amount allowed by the API.\n    // If multipleUploads is false, we only want to allow a single upload.\n    const maxFilesAllowed = !multipleUploads ? 1 : maxNumberOfFiles || apiMaxNumberOfFiles;\n    const numberOfUploads = Object.values(state.attachments).filter(({ localMetadata }) => localMetadata.uploadState && localMetadata.uploadState !== 'failed').length;\n    const maxFilesLeft = maxFilesAllowed - numberOfUploads;\n    const removeAttachments = useCallback((ids) => {\n        if (!ids.length)\n            return;\n        dispatch({ ids, type: 'removeAttachments' });\n    }, [dispatch]);\n    const upsertAttachments = useCallback((attachments) => {\n        if (!attachments.length)\n            return;\n        dispatch({\n            attachments: attachments.map(ensureIsLocalAttachment),\n            type: 'upsertAttachments',\n        });\n    }, [dispatch]);\n    const uploadAttachment = useCallback(async (att) => {\n        const { localMetadata, ...providedAttachmentData } = att;\n        if (!localMetadata?.file)\n            return att;\n        const { file } = localMetadata;\n        const isImage = isImageFile(file);\n        if (noFiles && !isImage)\n            return att;\n        const canUpload = await checkUploadPermissions({\n            addNotification,\n            file,\n            getAppSettings,\n            t,\n            uploadType: isImage ? 'image' : 'file',\n        });\n        if (!canUpload)\n            return att;\n        localMetadata.id = localMetadata?.id ?? nanoid();\n        const finalAttachment = {\n            type: getAttachmentTypeFromMime(file.type),\n        };\n        if (isImage) {\n            localMetadata.previewUri = URL.createObjectURL?.(file);\n            if (file instanceof File) {\n                finalAttachment.fallback = file.name;\n            }\n        }\n        else {\n            finalAttachment.file_size = file.size;\n            finalAttachment.mime_type = file.type;\n            if (file instanceof File) {\n                finalAttachment.title = file.name;\n            }\n        }\n        Object.assign(finalAttachment, providedAttachmentData);\n        upsertAttachments([\n            {\n                ...finalAttachment,\n                localMetadata: {\n                    ...localMetadata,\n                    uploadState: 'uploading',\n                },\n            },\n        ]);\n        let response;\n        try {\n            const doUploadRequest = isImage ? doImageUploadRequest : doFileUploadRequest;\n            if (doUploadRequest) {\n                response = await doUploadRequest(file, channel);\n            }\n            else {\n                response = await channel[isImage ? 'sendImage' : 'sendFile'](file);\n            }\n        }\n        catch (error) {\n            let finalError = { message: t('Error uploading attachment'), name: 'Error' };\n            if (typeof error.message === 'string') {\n                finalError = error;\n            }\n            else if (typeof error === 'object') {\n                finalError = Object.assign(finalError, error);\n            }\n            console.error(finalError);\n            addNotification(finalError.message, 'error');\n            const failedAttachment = {\n                ...finalAttachment,\n                localMetadata: {\n                    ...localMetadata,\n                    uploadState: 'failed',\n                },\n            };\n            upsertAttachments([failedAttachment]);\n            if (errorHandler) {\n                errorHandler(finalError, 'upload-attachment', { ...file, id: localMetadata.id });\n            }\n            return failedAttachment;\n        }\n        if (!response) {\n            // Copied this from useImageUpload / useFileUpload.\n            // If doUploadRequest returns any falsy value, then don't create the upload preview.\n            // This is for the case if someone wants to handle failure on app level.\n            removeAttachments([localMetadata.id]);\n            return;\n        }\n        const uploadedAttachment = {\n            ...finalAttachment,\n            localMetadata: {\n                ...localMetadata,\n                uploadState: 'finished',\n            },\n        };\n        if (isLocalImageAttachment(uploadedAttachment)) {\n            if (uploadedAttachment.localMetadata.previewUri) {\n                URL.revokeObjectURL(uploadedAttachment.localMetadata.previewUri);\n                delete uploadedAttachment.localMetadata.previewUri;\n            }\n            uploadedAttachment.image_url = response.file;\n        }\n        else {\n            uploadedAttachment.asset_url = response.file;\n        }\n        if (response.thumb_url) {\n            uploadedAttachment.thumb_url = response.thumb_url;\n        }\n        upsertAttachments([uploadedAttachment]);\n        return uploadedAttachment;\n    }, [\n        addNotification,\n        channel,\n        doFileUploadRequest,\n        doImageUploadRequest,\n        errorHandler,\n        getAppSettings,\n        noFiles,\n        removeAttachments,\n        t,\n        upsertAttachments,\n    ]);\n    const uploadNewFiles = useCallback((files) => {\n        const filesToBeUploaded = noFiles ? Array.from(files).filter(isImageFile) : Array.from(files);\n        filesToBeUploaded.slice(0, maxFilesLeft).forEach((fileLike) => {\n            uploadAttachment({\n                localMetadata: {\n                    file: isBlobButNotFile(fileLike)\n                        ? createFileFromBlobs({\n                            blobsArray: [fileLike],\n                            fileName: generateFileName(fileLike.type),\n                            mimeType: fileLike.type,\n                        })\n                        : fileLike,\n                    id: nanoid(),\n                },\n            });\n        });\n        textareaRef.current?.focus();\n    }, [maxFilesLeft, noFiles, textareaRef, uploadAttachment]);\n    return {\n        maxFilesLeft,\n        numberOfUploads,\n        removeAttachments,\n        uploadAttachment,\n        uploadNewFiles,\n        upsertAttachments,\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}