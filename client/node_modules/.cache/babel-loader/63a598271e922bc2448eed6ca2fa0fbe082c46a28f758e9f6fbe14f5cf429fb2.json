{"ast":null,"code":"import React from 'react';\nimport PropTypes from 'prop-types';\nimport Textarea from 'react-textarea-autosize';\nimport getCaretCoordinates from 'textarea-caret';\nimport { isValidElementType } from 'react-is';\nimport clsx from 'clsx';\nimport { List as DefaultSuggestionList } from './List';\nimport { DEFAULT_CARET_POSITION, defaultScrollToItem, errorMessage, triggerPropsCheck } from './utils';\nimport { CommandItem } from '../CommandItem';\nimport { UserItem } from '../UserItem';\nimport { isSafari } from '../../utils/browsers';\nexport class ReactTextareaAutocomplete extends React.Component {\n  constructor(props) {\n    super(props);\n    // FIXME: unused method\n    this.getSelectionPosition = () => {\n      if (!this.textareaRef) return null;\n      return {\n        selectionEnd: this.textareaRef.selectionEnd,\n        selectionStart: this.textareaRef.selectionStart\n      };\n    };\n    // FIXME: unused method\n    this.getSelectedText = () => {\n      if (!this.textareaRef) return null;\n      const {\n        selectionEnd,\n        selectionStart\n      } = this.textareaRef;\n      if (selectionStart === selectionEnd) return null;\n      return this.state.value.substr(selectionStart, selectionEnd - selectionStart);\n    };\n    this.setCaretPosition = (position = 0) => {\n      if (!this.textareaRef) return;\n      this.textareaRef.focus();\n      this.textareaRef.setSelectionRange(position, position);\n    };\n    this.getCaretPosition = () => {\n      if (!this.textareaRef) return 0;\n      return this.textareaRef.selectionEnd;\n    };\n    /**\n     * isComposing prevents double submissions in Korean and other languages.\n     * starting point for a read:\n     * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/isComposing\n     * In the long term, the fix should happen by handling keypress, but changing this has unknown implications.\n     * @param event React.KeyboardEvent\n     */\n    this._defaultShouldSubmit = event => event.key === 'Enter' && !event.shiftKey && !event.nativeEvent.isComposing;\n    this._handleKeyDown = event => {\n      const {\n        shouldSubmit = this._defaultShouldSubmit\n      } = this.props;\n      // prevent default behaviour when the selection list is rendered\n      if ((event.key === 'ArrowUp' || event.key === 'ArrowDown') && this.dropdownRef) event.preventDefault();\n      if (shouldSubmit?.(event)) return this._onEnter(event);\n      if (event.key === ' ') return this._onSpace(event);\n      if (event.key === 'Escape') return this._closeAutocomplete();\n    };\n    this._onEnter = async event => {\n      if (!this.textareaRef) return;\n      const trigger = this.state.currentTrigger;\n      if (!trigger || !this.state.data) {\n        // https://legacy.reactjs.org/docs/legacy-event-pooling.html\n        event.persist();\n        // trigger a submit\n        await this._replaceWord();\n        if (this.textareaRef) {\n          this.textareaRef.selectionEnd = 0;\n        }\n        this.props.handleSubmit(event);\n        this._closeAutocomplete();\n      }\n    };\n    this._onSpace = () => {\n      if (!this.props.replaceWord || !this.textareaRef) return;\n      // don't change characters if the element doesn't have focus\n      const hasFocus = this.textareaRef.matches(':focus');\n      if (!hasFocus) return;\n      this._replaceWord();\n    };\n    this._replaceWord = async () => {\n      const {\n        value\n      } = this.state;\n      const lastWordRegex = /([^\\s]+)(\\s*)$/;\n      const match = lastWordRegex.exec(value.slice(0, this.getCaretPosition()));\n      const lastWord = match && match[1];\n      if (!lastWord) return;\n      const spaces = match[2];\n      const newWord = await this.props.replaceWord(lastWord);\n      if (newWord == null) return;\n      const textBeforeWord = value.slice(0, this.getCaretPosition() - match[0].length);\n      const textAfterCaret = value.slice(this.getCaretPosition(), -1);\n      const newText = textBeforeWord + newWord + spaces + textAfterCaret;\n      this.setState({\n        value: newText\n      }, () => {\n        // fire onChange event after successful selection\n        const e = new CustomEvent('change', {\n          bubbles: true\n        });\n        this.textareaRef.dispatchEvent(e);\n        if (this.props.onChange) this.props.onChange(e);\n      });\n    };\n    this._onSelect = newToken => {\n      const {\n        closeCommandsList,\n        closeMentionsList,\n        onChange,\n        showCommandsList,\n        showMentionsList\n      } = this.props;\n      const {\n        currentTrigger: stateTrigger,\n        selectionEnd,\n        value: textareaValue\n      } = this.state;\n      const currentTrigger = showCommandsList ? '/' : showMentionsList ? '@' : stateTrigger;\n      if (!currentTrigger) return;\n      const computeCaretPosition = (position, token, startToken) => {\n        switch (position) {\n          case 'start':\n            return startToken;\n          case 'next':\n          case 'end':\n            return startToken + token.length;\n          default:\n            if (!Number.isInteger(position)) {\n              throw new Error('RTA: caretPosition should be \"start\", \"next\", \"end\" or number.');\n            }\n            return position;\n        }\n      };\n      const textToModify = showCommandsList ? '/' : showMentionsList ? '@' : textareaValue.slice(0, selectionEnd);\n      const startOfTokenPosition = textToModify.lastIndexOf(currentTrigger);\n      // we add space after emoji is selected if a caret position is next\n      const newTokenString = newToken.caretPosition === 'next' ? `${newToken.text} ` : newToken.text;\n      const newCaretPosition = computeCaretPosition(newToken.caretPosition, newTokenString, startOfTokenPosition);\n      const modifiedText = textToModify.substring(0, startOfTokenPosition) + newTokenString;\n      const valueToReplace = textareaValue.replace(textToModify, modifiedText);\n      // set the new textarea value and after that set the caret back to its position\n      this.setState({\n        dataLoading: false,\n        value: valueToReplace\n      }, () => {\n        // fire onChange event after successful selection\n        const e = new CustomEvent('change', {\n          bubbles: true\n        });\n        this.textareaRef.dispatchEvent(e);\n        if (onChange) onChange(e);\n        this.setCaretPosition(newCaretPosition);\n      });\n      this._closeAutocomplete();\n      if (showCommandsList) closeCommandsList();\n      if (showMentionsList) closeMentionsList();\n    };\n    this._getItemOnSelect = paramTrigger => {\n      const {\n        currentTrigger: stateTrigger\n      } = this.state;\n      const triggerSettings = this._getCurrentTriggerSettings(paramTrigger);\n      const currentTrigger = paramTrigger || stateTrigger;\n      if (!currentTrigger || !triggerSettings) return null;\n      const {\n        callback\n      } = triggerSettings;\n      if (!callback) return null;\n      return item => {\n        if (typeof callback !== 'function') {\n          throw new Error('Output functor is not defined! You have to define \"output\" function. https://github.com/webscopeio/react-textarea-autocomplete#trigger-type');\n        }\n        if (callback) {\n          return callback(item, currentTrigger);\n        }\n        return null;\n      };\n    };\n    this._getTextToReplace = paramTrigger => {\n      const {\n        actualToken,\n        currentTrigger: stateTrigger\n      } = this.state;\n      const triggerSettings = this._getCurrentTriggerSettings(paramTrigger);\n      const currentTrigger = paramTrigger || stateTrigger;\n      if (!currentTrigger || !triggerSettings) return null;\n      const {\n        output\n      } = triggerSettings;\n      return item => {\n        if (typeof item === 'object' && (!output || typeof output !== 'function')) {\n          throw new Error('Output functor is not defined! If you are using items as object you have to define \"output\" function. https://github.com/webscopeio/react-textarea-autocomplete#trigger-type');\n        }\n        if (output) {\n          const textToReplace = output(item, currentTrigger);\n          if (!textToReplace || typeof textToReplace === 'number') {\n            throw new Error(`Output functor should return string or object in shape {text: string, caretPosition: string | number}.\\nGot \"${String(textToReplace)}\". Check the implementation for trigger \"${currentTrigger}\" and its token \"${actualToken}\"\\n\\nSee https://github.com/webscopeio/react-textarea-autocomplete#trigger-type for more informations.\\n`);\n          }\n          if (typeof textToReplace === 'string') {\n            return {\n              caretPosition: DEFAULT_CARET_POSITION,\n              text: textToReplace\n            };\n          }\n          if (!textToReplace.text && currentTrigger !== ':') {\n            throw new Error(`Output \"text\" is not defined! Object should has shape {text: string, caretPosition: string | number}. Check the implementation for trigger \"${currentTrigger}\" and its token \"${actualToken}\"\\n`);\n          }\n          if (!textToReplace.caretPosition) {\n            throw new Error(`Output \"caretPosition\" is not defined! Object should has shape {text: string, caretPosition: string | number}. Check the implementation for trigger \"${currentTrigger}\" and its token \"${actualToken}\"\\n`);\n          }\n          return textToReplace;\n        }\n        if (typeof item !== 'string') {\n          throw new Error('Output item should be string\\n');\n        }\n        return {\n          caretPosition: DEFAULT_CARET_POSITION,\n          text: `${currentTrigger}${item}${currentTrigger}`\n        };\n      };\n    };\n    this._getCurrentTriggerSettings = paramTrigger => {\n      const {\n        currentTrigger: stateTrigger\n      } = this.state;\n      const currentTrigger = paramTrigger || stateTrigger;\n      if (!currentTrigger) return null;\n      return this.props.trigger[currentTrigger];\n    };\n    this._getValuesFromProvider = () => {\n      const {\n        actualToken,\n        currentTrigger\n      } = this.state;\n      const triggerSettings = this._getCurrentTriggerSettings();\n      if (!currentTrigger || !triggerSettings) return;\n      const {\n        component,\n        dataProvider\n      } = triggerSettings;\n      if (typeof dataProvider !== 'function') {\n        throw new Error('Trigger provider has to be a function!');\n      }\n      this.setState({\n        dataLoading: true\n      });\n      // Modified: send the full text to support / style commands\n      dataProvider(actualToken, this.state.value, (data, token) => {\n        // Make sure that the result is still relevant for current query\n        if (token !== this.state.actualToken) return;\n        if (!Array.isArray(data)) {\n          throw new Error('Trigger provider has to provide an array!');\n        }\n        if (!isValidElementType(component)) {\n          throw new Error('Component should be defined!');\n        }\n        // throw away if we resolved old trigger\n        if (currentTrigger !== this.state.currentTrigger) return;\n        // if we haven't resolved any data let's close the autocomplete\n        if (!data.length) {\n          this._closeAutocomplete();\n          return;\n        }\n        this.setState({\n          component,\n          data,\n          dataLoading: false\n        });\n      });\n    };\n    this._getSuggestions = paramTrigger => {\n      const {\n        currentTrigger: stateTrigger,\n        data\n      } = this.state;\n      const currentTrigger = paramTrigger || stateTrigger;\n      if (!currentTrigger || !data || data && !data.length) return null;\n      return data;\n    };\n    /**\n     * Close autocomplete, also clean up trigger (to avoid slow promises)\n     */\n    this._closeAutocomplete = () => {\n      this.setState({\n        currentTrigger: null,\n        data: null,\n        dataLoading: false,\n        left: null,\n        top: null\n      });\n    };\n    this._cleanUpProps = () => {\n      const props = {\n        ...this.props\n      };\n      const notSafe = ['additionalTextareaProps', 'className', 'closeCommandsList', 'closeMentionsList', 'closeOnClickOutside', 'containerClassName', 'containerStyle', 'disableMentions', 'dropdownClassName', 'dropdownStyle', 'grow', 'handleSubmit', 'innerRef', 'itemClassName', 'itemStyle', 'listClassName', 'listStyle', 'loaderClassName', 'loaderStyle', 'loadingComponent', 'minChar', 'movePopupAsYouType', 'onCaretPositionChange', 'onChange', 'ref', 'replaceWord', 'scrollToItem', 'shouldSubmit', 'showCommandsList', 'showMentionsList', 'SuggestionItem', 'SuggestionList', 'trigger', 'value'];\n      // eslint-disable-next-line\n      for (const prop in props) {\n        if (notSafe.includes(prop)) delete props[prop];\n      }\n      return props;\n    };\n    this._isCommand = text => {\n      if (text[0] !== '/') return false;\n      const tokens = text.split(' ');\n      return tokens.length <= 1;\n    };\n    this._changeHandler = e => {\n      const {\n        minChar,\n        movePopupAsYouType,\n        onCaretPositionChange,\n        onChange,\n        trigger\n      } = this.props;\n      const {\n        left,\n        top\n      } = this.state;\n      const textarea = e.target;\n      const {\n        selectionEnd,\n        selectionStart,\n        value\n      } = textarea;\n      if (onChange) {\n        e.persist();\n        onChange(e);\n      }\n      if (onCaretPositionChange) onCaretPositionChange(this.getCaretPosition());\n      this.setState({\n        value\n      });\n      let currentTrigger;\n      let lastToken;\n      if (this._isCommand(value)) {\n        currentTrigger = '/';\n        lastToken = value;\n      } else {\n        const triggerTokens = Object.keys(trigger).join().replace('/', '');\n        const triggerNorWhitespace = `[^\\\\s${triggerTokens}]*`;\n        const regex = new RegExp(`(?!^|\\\\W)?[${triggerTokens}]${triggerNorWhitespace}\\\\s?${triggerNorWhitespace}$`, 'g');\n        const tokenMatch = value.slice(0, selectionEnd).match(regex);\n        lastToken = tokenMatch && tokenMatch[tokenMatch.length - 1].trim();\n        currentTrigger = lastToken && Object.keys(trigger).find(a => a === lastToken[0]) || null;\n      }\n      /*\n       if we lost the trigger token or there is no following character we want to close\n       the autocomplete\n      */\n      if (!lastToken || lastToken.length <= minChar) {\n        this._closeAutocomplete();\n        return;\n      }\n      const actualToken = lastToken.slice(1);\n      // if trigger is not configured step out from the function, otherwise proceed\n      if (!currentTrigger) return;\n      if (movePopupAsYouType || top === null && left === null ||\n      // if we have single char - trigger it means we want to re-position the autocomplete\n      lastToken.length === 1) {\n        const {\n          left: newLeft,\n          top: newTop\n        } = getCaretCoordinates(textarea, selectionEnd);\n        this.setState({\n          // make position relative to textarea\n          left: newLeft,\n          top: newTop - this.textareaRef.scrollTop || 0\n        });\n      }\n      this.setState({\n        actualToken,\n        currentTrigger,\n        selectionEnd,\n        selectionStart\n      }, () => {\n        try {\n          this._getValuesFromProvider();\n        } catch (err) {\n          errorMessage(err.message);\n        }\n      });\n    };\n    this._selectHandler = e => {\n      const {\n        onCaretPositionChange,\n        onSelect\n      } = this.props;\n      if (onCaretPositionChange) onCaretPositionChange(this.getCaretPosition());\n      if (onSelect) {\n        e.persist();\n        onSelect(e);\n      }\n    };\n    // The textarea itself is outside the auto-select dropdown.\n    this._onClickAndBlurHandler = e => {\n      const {\n        closeOnClickOutside,\n        onBlur\n      } = this.props;\n      // If this is a click: e.target is the textarea, and e.relatedTarget is the thing\n      // that was actually clicked. If we clicked inside the auto-select dropdown, then\n      // that's not a blur, from the auto-select point of view, so then do nothing.\n      const el = e.relatedTarget;\n      // If this is a blur event in Safari, then relatedTarget is never a dropdown item, but a common parent\n      // of textarea and dropdown container. That means that dropdownRef will not contain its parent and the\n      // autocomplete will be closed before onclick handler can be invoked selecting an item.\n      // It seems that Safari has different implementation determining the relatedTarget node than Chrome and Firefox.\n      // Therefore, if focused away in Safari, the dropdown will be kept rendered until pressing Esc or selecting and item from it.\n      const focusedAwayInSafari = isSafari() && e.type === 'blur';\n      if (this.dropdownRef && el instanceof Node && this.dropdownRef.contains(el) || focusedAwayInSafari) {\n        return;\n      }\n      if (closeOnClickOutside) this._closeAutocomplete();\n      if (onBlur) {\n        e.persist();\n        onBlur(e);\n      }\n    };\n    this._onScrollHandler = () => this._closeAutocomplete();\n    this._dropdownScroll = item => {\n      const {\n        scrollToItem\n      } = this.props;\n      if (!scrollToItem) return;\n      if (scrollToItem === true) {\n        defaultScrollToItem(this.dropdownRef, item);\n        return;\n      }\n      if (typeof scrollToItem !== 'function' || scrollToItem.length !== 2) {\n        throw new Error('`scrollToItem` has to be boolean (true for default implementation) or function with two parameters: container, item.');\n      }\n      scrollToItem(this.dropdownRef, item);\n    };\n    this.getTriggerProps = () => {\n      const {\n        showCommandsList,\n        showMentionsList,\n        trigger\n      } = this.props;\n      const {\n        component,\n        currentTrigger,\n        selectionEnd,\n        value\n      } = this.state;\n      const selectedItem = this._getItemOnSelect();\n      const suggestionData = this._getSuggestions();\n      const textToReplace = this._getTextToReplace();\n      const triggerProps = {\n        component,\n        currentTrigger,\n        getSelectedItem: selectedItem,\n        getTextToReplace: textToReplace,\n        selectionEnd,\n        value,\n        values: suggestionData\n      };\n      if (showCommandsList && trigger['/'] || showMentionsList && trigger['@']) {\n        let currentCommands;\n        const getCommands = trigger[showCommandsList ? '/' : '@'].dataProvider;\n        getCommands?.('', showCommandsList ? '/' : '@', data => {\n          currentCommands = data;\n        });\n        triggerProps.component = showCommandsList ? CommandItem : UserItem;\n        triggerProps.currentTrigger = showCommandsList ? '/' : '@';\n        triggerProps.getTextToReplace = this._getTextToReplace(showCommandsList ? '/' : '@');\n        triggerProps.getSelectedItem = this._getItemOnSelect(showCommandsList ? '/' : '@');\n        triggerProps.selectionEnd = 1;\n        triggerProps.value = showCommandsList ? '/' : '@';\n        triggerProps.values = currentCommands;\n      }\n      return triggerProps;\n    };\n    this.setDropdownRef = element => {\n      this.dropdownRef = element;\n    };\n    const {\n      loadingComponent,\n      trigger,\n      value\n    } = this.props;\n    // TODO: it would be better to have the parent control state...\n    // if (value) this.state.value = value;\n    if (!loadingComponent) {\n      throw new Error('RTA: loadingComponent is not defined');\n    }\n    if (!trigger) {\n      throw new Error('RTA: trigger is not defined');\n    }\n    this.state = {\n      actualToken: '',\n      component: null,\n      currentTrigger: null,\n      data: null,\n      dataLoading: false,\n      isComposing: false,\n      left: null,\n      selectionEnd: 0,\n      selectionStart: 0,\n      top: null,\n      value: value || ''\n    };\n  }\n  /**\n   * setup to emulate the UNSAFE_componentWillReceiveProps\n   */\n  static getDerivedStateFromProps(props, state) {\n    if (props.value !== state.propsValue || !state.value) {\n      return {\n        propsValue: props.value,\n        value: props.value\n      };\n    } else {\n      return null;\n    }\n  }\n  renderSuggestionListContainer() {\n    const {\n      disableMentions,\n      dropdownClassName,\n      dropdownStyle,\n      itemClassName,\n      itemStyle,\n      listClassName,\n      SuggestionItem,\n      SuggestionList = DefaultSuggestionList\n    } = this.props;\n    const {\n      isComposing\n    } = this.state;\n    const triggerProps = this.getTriggerProps();\n    if (isComposing || !triggerProps.values || !triggerProps.currentTrigger || disableMentions && triggerProps.currentTrigger === '@') return null;\n    return React.createElement(\"div\", {\n      className: clsx('str-chat__suggestion-list-container', dropdownClassName),\n      ref: this.setDropdownRef,\n      style: dropdownStyle\n    }, React.createElement(SuggestionList, {\n      className: listClassName,\n      dropdownScroll: this._dropdownScroll,\n      itemClassName: clsx('str-chat__suggestion-list-item', itemClassName),\n      itemStyle: itemStyle,\n      onSelect: this._onSelect,\n      SuggestionItem: SuggestionItem,\n      ...triggerProps\n    }));\n  }\n  render() {\n    const {\n      className,\n      containerClassName,\n      containerStyle,\n      style\n    } = this.props;\n    const {\n      onBlur,\n      onChange,\n      onClick,\n      onFocus,\n      onKeyDown,\n      onScroll,\n      onSelect,\n      ...restAdditionalTextareaProps\n    } = this.props.additionalTextareaProps || {};\n    let {\n      maxRows\n    } = this.props;\n    const {\n      dataLoading,\n      value\n    } = this.state;\n    if (!this.props.grow) maxRows = 1;\n    // By setting defaultValue to undefined, avoid error:\n    // ForwardRef(TextareaAutosize) contains a textarea with both value and defaultValue props.\n    // Textarea elements must be either controlled or uncontrolled\n    return React.createElement(\"div\", {\n      className: clsx('rta', containerClassName, {\n        ['rta--loading']: dataLoading\n      }),\n      style: containerStyle\n    }, this.renderSuggestionListContainer(), React.createElement(Textarea, {\n      \"data-testid\": 'message-input',\n      ...this._cleanUpProps(),\n      className: clsx('rta__textarea', className),\n      maxRows: maxRows,\n      onBlur: e => {\n        this._onClickAndBlurHandler(e);\n        onBlur?.(e);\n      },\n      onChange: e => {\n        this._changeHandler(e);\n        onChange?.(e);\n      },\n      onClick: e => {\n        this._onClickAndBlurHandler(e);\n        onClick?.(e);\n      },\n      onCompositionEnd: () => this.setState(pv => ({\n        ...pv,\n        isComposing: false\n      })),\n      onCompositionStart: () => this.setState(pv => ({\n        ...pv,\n        isComposing: true\n      })),\n      onFocus: e => {\n        this.props.onFocus?.(e);\n        onFocus?.(e);\n      },\n      onKeyDown: e => {\n        this._handleKeyDown(e);\n        onKeyDown?.(e);\n      },\n      onScroll: e => {\n        this._onScrollHandler(e);\n        onScroll?.(e);\n      },\n      onSelect: e => {\n        this._selectHandler(e);\n        onSelect?.(e);\n      },\n      ref: ref => {\n        this.props?.innerRef(ref);\n        this.textareaRef = ref;\n      },\n      style: style,\n      value: value,\n      ...restAdditionalTextareaProps,\n      defaultValue: undefined\n    }));\n  }\n}\nReactTextareaAutocomplete.defaultProps = {\n  closeOnClickOutside: true,\n  maxRows: 10,\n  minChar: 1,\n  movePopupAsYouType: false,\n  scrollToItem: true,\n  value: ''\n};\nReactTextareaAutocomplete.propTypes = {\n  className: PropTypes.string,\n  closeOnClickOutside: PropTypes.bool,\n  containerClassName: PropTypes.string,\n  containerStyle: PropTypes.object,\n  disableMentions: PropTypes.bool,\n  dropdownClassName: PropTypes.string,\n  dropdownStyle: PropTypes.object,\n  itemClassName: PropTypes.string,\n  itemStyle: PropTypes.object,\n  listClassName: PropTypes.string,\n  listStyle: PropTypes.object,\n  loaderClassName: PropTypes.string,\n  loaderStyle: PropTypes.object,\n  loadingComponent: PropTypes.elementType,\n  minChar: PropTypes.number,\n  onBlur: PropTypes.func,\n  onCaretPositionChange: PropTypes.func,\n  onChange: PropTypes.func,\n  onSelect: PropTypes.func,\n  shouldSubmit: PropTypes.func,\n  style: PropTypes.object,\n  SuggestionList: PropTypes.elementType,\n  trigger: triggerPropsCheck,\n  value: PropTypes.string\n};","map":{"version":3,"names":["React","PropTypes","Textarea","getCaretCoordinates","isValidElementType","clsx","List","DefaultSuggestionList","DEFAULT_CARET_POSITION","defaultScrollToItem","errorMessage","triggerPropsCheck","CommandItem","UserItem","isSafari","ReactTextareaAutocomplete","Component","constructor","props","getSelectionPosition","textareaRef","selectionEnd","selectionStart","getSelectedText","state","value","substr","setCaretPosition","position","focus","setSelectionRange","getCaretPosition","_defaultShouldSubmit","event","key","shiftKey","nativeEvent","isComposing","_handleKeyDown","shouldSubmit","dropdownRef","preventDefault","_onEnter","_onSpace","_closeAutocomplete","trigger","currentTrigger","data","persist","_replaceWord","handleSubmit","replaceWord","hasFocus","matches","lastWordRegex","match","exec","slice","lastWord","spaces","newWord","textBeforeWord","length","textAfterCaret","newText","setState","e","CustomEvent","bubbles","dispatchEvent","onChange","_onSelect","newToken","closeCommandsList","closeMentionsList","showCommandsList","showMentionsList","stateTrigger","textareaValue","computeCaretPosition","token","startToken","Number","isInteger","Error","textToModify","startOfTokenPosition","lastIndexOf","newTokenString","caretPosition","text","newCaretPosition","modifiedText","substring","valueToReplace","replace","dataLoading","_getItemOnSelect","paramTrigger","triggerSettings","_getCurrentTriggerSettings","callback","item","_getTextToReplace","actualToken","output","textToReplace","String","_getValuesFromProvider","component","dataProvider","Array","isArray","_getSuggestions","left","top","_cleanUpProps","notSafe","prop","includes","_isCommand","tokens","split","_changeHandler","minChar","movePopupAsYouType","onCaretPositionChange","textarea","target","lastToken","triggerTokens","Object","keys","join","triggerNorWhitespace","regex","RegExp","tokenMatch","trim","find","a","newLeft","newTop","scrollTop","err","message","_selectHandler","onSelect","_onClickAndBlurHandler","closeOnClickOutside","onBlur","el","relatedTarget","focusedAwayInSafari","type","Node","contains","_onScrollHandler","_dropdownScroll","scrollToItem","getTriggerProps","selectedItem","suggestionData","triggerProps","getSelectedItem","getTextToReplace","values","currentCommands","getCommands","setDropdownRef","element","loadingComponent","getDerivedStateFromProps","propsValue","renderSuggestionListContainer","disableMentions","dropdownClassName","dropdownStyle","itemClassName","itemStyle","listClassName","SuggestionItem","SuggestionList","createElement","className","ref","style","dropdownScroll","render","containerClassName","containerStyle","onClick","onFocus","onKeyDown","onScroll","restAdditionalTextareaProps","additionalTextareaProps","maxRows","grow","onCompositionEnd","pv","onCompositionStart","innerRef","defaultValue","undefined","defaultProps","propTypes","string","bool","object","listStyle","loaderClassName","loaderStyle","elementType","number","func"],"sources":["C:/Users/abdel/OneDrive/Desktop/Medical-plager/client/node_modules/stream-chat-react/dist/components/AutoCompleteTextarea/Textarea.js"],"sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport Textarea from 'react-textarea-autosize';\nimport getCaretCoordinates from 'textarea-caret';\nimport { isValidElementType } from 'react-is';\nimport clsx from 'clsx';\nimport { List as DefaultSuggestionList } from './List';\nimport { DEFAULT_CARET_POSITION, defaultScrollToItem, errorMessage, triggerPropsCheck, } from './utils';\nimport { CommandItem } from '../CommandItem';\nimport { UserItem } from '../UserItem';\nimport { isSafari } from '../../utils/browsers';\nexport class ReactTextareaAutocomplete extends React.Component {\n    constructor(props) {\n        super(props);\n        // FIXME: unused method\n        this.getSelectionPosition = () => {\n            if (!this.textareaRef)\n                return null;\n            return {\n                selectionEnd: this.textareaRef.selectionEnd,\n                selectionStart: this.textareaRef.selectionStart,\n            };\n        };\n        // FIXME: unused method\n        this.getSelectedText = () => {\n            if (!this.textareaRef)\n                return null;\n            const { selectionEnd, selectionStart } = this.textareaRef;\n            if (selectionStart === selectionEnd)\n                return null;\n            return this.state.value.substr(selectionStart, selectionEnd - selectionStart);\n        };\n        this.setCaretPosition = (position = 0) => {\n            if (!this.textareaRef)\n                return;\n            this.textareaRef.focus();\n            this.textareaRef.setSelectionRange(position, position);\n        };\n        this.getCaretPosition = () => {\n            if (!this.textareaRef)\n                return 0;\n            return this.textareaRef.selectionEnd;\n        };\n        /**\n         * isComposing prevents double submissions in Korean and other languages.\n         * starting point for a read:\n         * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/isComposing\n         * In the long term, the fix should happen by handling keypress, but changing this has unknown implications.\n         * @param event React.KeyboardEvent\n         */\n        this._defaultShouldSubmit = (event) => event.key === 'Enter' && !event.shiftKey && !event.nativeEvent.isComposing;\n        this._handleKeyDown = (event) => {\n            const { shouldSubmit = this._defaultShouldSubmit } = this.props;\n            // prevent default behaviour when the selection list is rendered\n            if ((event.key === 'ArrowUp' || event.key === 'ArrowDown') && this.dropdownRef)\n                event.preventDefault();\n            if (shouldSubmit?.(event))\n                return this._onEnter(event);\n            if (event.key === ' ')\n                return this._onSpace(event);\n            if (event.key === 'Escape')\n                return this._closeAutocomplete();\n        };\n        this._onEnter = async (event) => {\n            if (!this.textareaRef)\n                return;\n            const trigger = this.state.currentTrigger;\n            if (!trigger || !this.state.data) {\n                // https://legacy.reactjs.org/docs/legacy-event-pooling.html\n                event.persist();\n                // trigger a submit\n                await this._replaceWord();\n                if (this.textareaRef) {\n                    this.textareaRef.selectionEnd = 0;\n                }\n                this.props.handleSubmit(event);\n                this._closeAutocomplete();\n            }\n        };\n        this._onSpace = () => {\n            if (!this.props.replaceWord || !this.textareaRef)\n                return;\n            // don't change characters if the element doesn't have focus\n            const hasFocus = this.textareaRef.matches(':focus');\n            if (!hasFocus)\n                return;\n            this._replaceWord();\n        };\n        this._replaceWord = async () => {\n            const { value } = this.state;\n            const lastWordRegex = /([^\\s]+)(\\s*)$/;\n            const match = lastWordRegex.exec(value.slice(0, this.getCaretPosition()));\n            const lastWord = match && match[1];\n            if (!lastWord)\n                return;\n            const spaces = match[2];\n            const newWord = await this.props.replaceWord(lastWord);\n            if (newWord == null)\n                return;\n            const textBeforeWord = value.slice(0, this.getCaretPosition() - match[0].length);\n            const textAfterCaret = value.slice(this.getCaretPosition(), -1);\n            const newText = textBeforeWord + newWord + spaces + textAfterCaret;\n            this.setState({\n                value: newText,\n            }, () => {\n                // fire onChange event after successful selection\n                const e = new CustomEvent('change', { bubbles: true });\n                this.textareaRef.dispatchEvent(e);\n                if (this.props.onChange)\n                    this.props.onChange(e);\n            });\n        };\n        this._onSelect = (newToken) => {\n            const { closeCommandsList, closeMentionsList, onChange, showCommandsList, showMentionsList, } = this.props;\n            const { currentTrigger: stateTrigger, selectionEnd, value: textareaValue } = this.state;\n            const currentTrigger = showCommandsList ? '/' : showMentionsList ? '@' : stateTrigger;\n            if (!currentTrigger)\n                return;\n            const computeCaretPosition = (position, token, startToken) => {\n                switch (position) {\n                    case 'start':\n                        return startToken;\n                    case 'next':\n                    case 'end':\n                        return startToken + token.length;\n                    default:\n                        if (!Number.isInteger(position)) {\n                            throw new Error('RTA: caretPosition should be \"start\", \"next\", \"end\" or number.');\n                        }\n                        return position;\n                }\n            };\n            const textToModify = showCommandsList\n                ? '/'\n                : showMentionsList\n                    ? '@'\n                    : textareaValue.slice(0, selectionEnd);\n            const startOfTokenPosition = textToModify.lastIndexOf(currentTrigger);\n            // we add space after emoji is selected if a caret position is next\n            const newTokenString = newToken.caretPosition === 'next' ? `${newToken.text} ` : newToken.text;\n            const newCaretPosition = computeCaretPosition(newToken.caretPosition, newTokenString, startOfTokenPosition);\n            const modifiedText = textToModify.substring(0, startOfTokenPosition) + newTokenString;\n            const valueToReplace = textareaValue.replace(textToModify, modifiedText);\n            // set the new textarea value and after that set the caret back to its position\n            this.setState({\n                dataLoading: false,\n                value: valueToReplace,\n            }, () => {\n                // fire onChange event after successful selection\n                const e = new CustomEvent('change', { bubbles: true });\n                this.textareaRef.dispatchEvent(e);\n                if (onChange)\n                    onChange(e);\n                this.setCaretPosition(newCaretPosition);\n            });\n            this._closeAutocomplete();\n            if (showCommandsList)\n                closeCommandsList();\n            if (showMentionsList)\n                closeMentionsList();\n        };\n        this._getItemOnSelect = (paramTrigger) => {\n            const { currentTrigger: stateTrigger } = this.state;\n            const triggerSettings = this._getCurrentTriggerSettings(paramTrigger);\n            const currentTrigger = paramTrigger || stateTrigger;\n            if (!currentTrigger || !triggerSettings)\n                return null;\n            const { callback } = triggerSettings;\n            if (!callback)\n                return null;\n            return (item) => {\n                if (typeof callback !== 'function') {\n                    throw new Error('Output functor is not defined! You have to define \"output\" function. https://github.com/webscopeio/react-textarea-autocomplete#trigger-type');\n                }\n                if (callback) {\n                    return callback(item, currentTrigger);\n                }\n                return null;\n            };\n        };\n        this._getTextToReplace = (paramTrigger) => {\n            const { actualToken, currentTrigger: stateTrigger } = this.state;\n            const triggerSettings = this._getCurrentTriggerSettings(paramTrigger);\n            const currentTrigger = paramTrigger || stateTrigger;\n            if (!currentTrigger || !triggerSettings)\n                return null;\n            const { output } = triggerSettings;\n            return (item) => {\n                if (typeof item === 'object' && (!output || typeof output !== 'function')) {\n                    throw new Error('Output functor is not defined! If you are using items as object you have to define \"output\" function. https://github.com/webscopeio/react-textarea-autocomplete#trigger-type');\n                }\n                if (output) {\n                    const textToReplace = output(item, currentTrigger);\n                    if (!textToReplace || typeof textToReplace === 'number') {\n                        throw new Error(`Output functor should return string or object in shape {text: string, caretPosition: string | number}.\\nGot \"${String(textToReplace)}\". Check the implementation for trigger \"${currentTrigger}\" and its token \"${actualToken}\"\\n\\nSee https://github.com/webscopeio/react-textarea-autocomplete#trigger-type for more informations.\\n`);\n                    }\n                    if (typeof textToReplace === 'string') {\n                        return {\n                            caretPosition: DEFAULT_CARET_POSITION,\n                            text: textToReplace,\n                        };\n                    }\n                    if (!textToReplace.text && currentTrigger !== ':') {\n                        throw new Error(`Output \"text\" is not defined! Object should has shape {text: string, caretPosition: string | number}. Check the implementation for trigger \"${currentTrigger}\" and its token \"${actualToken}\"\\n`);\n                    }\n                    if (!textToReplace.caretPosition) {\n                        throw new Error(`Output \"caretPosition\" is not defined! Object should has shape {text: string, caretPosition: string | number}. Check the implementation for trigger \"${currentTrigger}\" and its token \"${actualToken}\"\\n`);\n                    }\n                    return textToReplace;\n                }\n                if (typeof item !== 'string') {\n                    throw new Error('Output item should be string\\n');\n                }\n                return {\n                    caretPosition: DEFAULT_CARET_POSITION,\n                    text: `${currentTrigger}${item}${currentTrigger}`,\n                };\n            };\n        };\n        this._getCurrentTriggerSettings = (paramTrigger) => {\n            const { currentTrigger: stateTrigger } = this.state;\n            const currentTrigger = paramTrigger || stateTrigger;\n            if (!currentTrigger)\n                return null;\n            return this.props.trigger[currentTrigger];\n        };\n        this._getValuesFromProvider = () => {\n            const { actualToken, currentTrigger } = this.state;\n            const triggerSettings = this._getCurrentTriggerSettings();\n            if (!currentTrigger || !triggerSettings)\n                return;\n            const { component, dataProvider } = triggerSettings;\n            if (typeof dataProvider !== 'function') {\n                throw new Error('Trigger provider has to be a function!');\n            }\n            this.setState({ dataLoading: true });\n            // Modified: send the full text to support / style commands\n            dataProvider(actualToken, this.state.value, (data, token) => {\n                // Make sure that the result is still relevant for current query\n                if (token !== this.state.actualToken)\n                    return;\n                if (!Array.isArray(data)) {\n                    throw new Error('Trigger provider has to provide an array!');\n                }\n                if (!isValidElementType(component)) {\n                    throw new Error('Component should be defined!');\n                }\n                // throw away if we resolved old trigger\n                if (currentTrigger !== this.state.currentTrigger)\n                    return;\n                // if we haven't resolved any data let's close the autocomplete\n                if (!data.length) {\n                    this._closeAutocomplete();\n                    return;\n                }\n                this.setState({\n                    component,\n                    data,\n                    dataLoading: false,\n                });\n            });\n        };\n        this._getSuggestions = (paramTrigger) => {\n            const { currentTrigger: stateTrigger, data } = this.state;\n            const currentTrigger = paramTrigger || stateTrigger;\n            if (!currentTrigger || !data || (data && !data.length))\n                return null;\n            return data;\n        };\n        /**\n         * Close autocomplete, also clean up trigger (to avoid slow promises)\n         */\n        this._closeAutocomplete = () => {\n            this.setState({\n                currentTrigger: null,\n                data: null,\n                dataLoading: false,\n                left: null,\n                top: null,\n            });\n        };\n        this._cleanUpProps = () => {\n            const props = { ...this.props };\n            const notSafe = [\n                'additionalTextareaProps',\n                'className',\n                'closeCommandsList',\n                'closeMentionsList',\n                'closeOnClickOutside',\n                'containerClassName',\n                'containerStyle',\n                'disableMentions',\n                'dropdownClassName',\n                'dropdownStyle',\n                'grow',\n                'handleSubmit',\n                'innerRef',\n                'itemClassName',\n                'itemStyle',\n                'listClassName',\n                'listStyle',\n                'loaderClassName',\n                'loaderStyle',\n                'loadingComponent',\n                'minChar',\n                'movePopupAsYouType',\n                'onCaretPositionChange',\n                'onChange',\n                'ref',\n                'replaceWord',\n                'scrollToItem',\n                'shouldSubmit',\n                'showCommandsList',\n                'showMentionsList',\n                'SuggestionItem',\n                'SuggestionList',\n                'trigger',\n                'value',\n            ];\n            // eslint-disable-next-line\n            for (const prop in props) {\n                if (notSafe.includes(prop))\n                    delete props[prop];\n            }\n            return props;\n        };\n        this._isCommand = (text) => {\n            if (text[0] !== '/')\n                return false;\n            const tokens = text.split(' ');\n            return tokens.length <= 1;\n        };\n        this._changeHandler = (e) => {\n            const { minChar, movePopupAsYouType, onCaretPositionChange, onChange, trigger } = this.props;\n            const { left, top } = this.state;\n            const textarea = e.target;\n            const { selectionEnd, selectionStart, value } = textarea;\n            if (onChange) {\n                e.persist();\n                onChange(e);\n            }\n            if (onCaretPositionChange)\n                onCaretPositionChange(this.getCaretPosition());\n            this.setState({ value });\n            let currentTrigger;\n            let lastToken;\n            if (this._isCommand(value)) {\n                currentTrigger = '/';\n                lastToken = value;\n            }\n            else {\n                const triggerTokens = Object.keys(trigger).join().replace('/', '');\n                const triggerNorWhitespace = `[^\\\\s${triggerTokens}]*`;\n                const regex = new RegExp(`(?!^|\\\\W)?[${triggerTokens}]${triggerNorWhitespace}\\\\s?${triggerNorWhitespace}$`, 'g');\n                const tokenMatch = value.slice(0, selectionEnd).match(regex);\n                lastToken = tokenMatch && tokenMatch[tokenMatch.length - 1].trim();\n                currentTrigger = (lastToken && Object.keys(trigger).find((a) => a === lastToken[0])) || null;\n            }\n            /*\n             if we lost the trigger token or there is no following character we want to close\n             the autocomplete\n            */\n            if (!lastToken || lastToken.length <= minChar) {\n                this._closeAutocomplete();\n                return;\n            }\n            const actualToken = lastToken.slice(1);\n            // if trigger is not configured step out from the function, otherwise proceed\n            if (!currentTrigger)\n                return;\n            if (movePopupAsYouType ||\n                (top === null && left === null) ||\n                // if we have single char - trigger it means we want to re-position the autocomplete\n                lastToken.length === 1) {\n                const { left: newLeft, top: newTop } = getCaretCoordinates(textarea, selectionEnd);\n                this.setState({\n                    // make position relative to textarea\n                    left: newLeft,\n                    top: newTop - this.textareaRef.scrollTop || 0,\n                });\n            }\n            this.setState({\n                actualToken,\n                currentTrigger,\n                selectionEnd,\n                selectionStart,\n            }, () => {\n                try {\n                    this._getValuesFromProvider();\n                }\n                catch (err) {\n                    errorMessage(err.message);\n                }\n            });\n        };\n        this._selectHandler = (e) => {\n            const { onCaretPositionChange, onSelect } = this.props;\n            if (onCaretPositionChange)\n                onCaretPositionChange(this.getCaretPosition());\n            if (onSelect) {\n                e.persist();\n                onSelect(e);\n            }\n        };\n        // The textarea itself is outside the auto-select dropdown.\n        this._onClickAndBlurHandler = (e) => {\n            const { closeOnClickOutside, onBlur } = this.props;\n            // If this is a click: e.target is the textarea, and e.relatedTarget is the thing\n            // that was actually clicked. If we clicked inside the auto-select dropdown, then\n            // that's not a blur, from the auto-select point of view, so then do nothing.\n            const el = e.relatedTarget;\n            // If this is a blur event in Safari, then relatedTarget is never a dropdown item, but a common parent\n            // of textarea and dropdown container. That means that dropdownRef will not contain its parent and the\n            // autocomplete will be closed before onclick handler can be invoked selecting an item.\n            // It seems that Safari has different implementation determining the relatedTarget node than Chrome and Firefox.\n            // Therefore, if focused away in Safari, the dropdown will be kept rendered until pressing Esc or selecting and item from it.\n            const focusedAwayInSafari = isSafari() && e.type === 'blur';\n            if ((this.dropdownRef && el instanceof Node && this.dropdownRef.contains(el)) ||\n                focusedAwayInSafari) {\n                return;\n            }\n            if (closeOnClickOutside)\n                this._closeAutocomplete();\n            if (onBlur) {\n                e.persist();\n                onBlur(e);\n            }\n        };\n        this._onScrollHandler = () => this._closeAutocomplete();\n        this._dropdownScroll = (item) => {\n            const { scrollToItem } = this.props;\n            if (!scrollToItem)\n                return;\n            if (scrollToItem === true) {\n                defaultScrollToItem(this.dropdownRef, item);\n                return;\n            }\n            if (typeof scrollToItem !== 'function' || scrollToItem.length !== 2) {\n                throw new Error('`scrollToItem` has to be boolean (true for default implementation) or function with two parameters: container, item.');\n            }\n            scrollToItem(this.dropdownRef, item);\n        };\n        this.getTriggerProps = () => {\n            const { showCommandsList, showMentionsList, trigger } = this.props;\n            const { component, currentTrigger, selectionEnd, value } = this.state;\n            const selectedItem = this._getItemOnSelect();\n            const suggestionData = this._getSuggestions();\n            const textToReplace = this._getTextToReplace();\n            const triggerProps = {\n                component,\n                currentTrigger,\n                getSelectedItem: selectedItem,\n                getTextToReplace: textToReplace,\n                selectionEnd,\n                value,\n                values: suggestionData,\n            };\n            if ((showCommandsList && trigger['/']) || (showMentionsList && trigger['@'])) {\n                let currentCommands;\n                const getCommands = trigger[showCommandsList ? '/' : '@'].dataProvider;\n                getCommands?.('', showCommandsList ? '/' : '@', (data) => {\n                    currentCommands = data;\n                });\n                triggerProps.component = showCommandsList ? CommandItem : UserItem;\n                triggerProps.currentTrigger = showCommandsList ? '/' : '@';\n                triggerProps.getTextToReplace = this._getTextToReplace(showCommandsList ? '/' : '@');\n                triggerProps.getSelectedItem = this._getItemOnSelect(showCommandsList ? '/' : '@');\n                triggerProps.selectionEnd = 1;\n                triggerProps.value = showCommandsList ? '/' : '@';\n                triggerProps.values = currentCommands;\n            }\n            return triggerProps;\n        };\n        this.setDropdownRef = (element) => {\n            this.dropdownRef = element;\n        };\n        const { loadingComponent, trigger, value } = this.props;\n        // TODO: it would be better to have the parent control state...\n        // if (value) this.state.value = value;\n        if (!loadingComponent) {\n            throw new Error('RTA: loadingComponent is not defined');\n        }\n        if (!trigger) {\n            throw new Error('RTA: trigger is not defined');\n        }\n        this.state = {\n            actualToken: '',\n            component: null,\n            currentTrigger: null,\n            data: null,\n            dataLoading: false,\n            isComposing: false,\n            left: null,\n            selectionEnd: 0,\n            selectionStart: 0,\n            top: null,\n            value: value || '',\n        };\n    }\n    /**\n     * setup to emulate the UNSAFE_componentWillReceiveProps\n     */\n    static getDerivedStateFromProps(props, state) {\n        if (props.value !== state.propsValue || !state.value) {\n            return { propsValue: props.value, value: props.value };\n        }\n        else {\n            return null;\n        }\n    }\n    renderSuggestionListContainer() {\n        const { disableMentions, dropdownClassName, dropdownStyle, itemClassName, itemStyle, listClassName, SuggestionItem, SuggestionList = DefaultSuggestionList, } = this.props;\n        const { isComposing } = this.state;\n        const triggerProps = this.getTriggerProps();\n        if (isComposing ||\n            !triggerProps.values ||\n            !triggerProps.currentTrigger ||\n            (disableMentions && triggerProps.currentTrigger === '@'))\n            return null;\n        return (React.createElement(\"div\", { className: clsx('str-chat__suggestion-list-container', dropdownClassName), ref: this.setDropdownRef, style: dropdownStyle },\n            React.createElement(SuggestionList, { className: listClassName, dropdownScroll: this._dropdownScroll, itemClassName: clsx('str-chat__suggestion-list-item', itemClassName), itemStyle: itemStyle, onSelect: this._onSelect, SuggestionItem: SuggestionItem, ...triggerProps })));\n    }\n    render() {\n        const { className, containerClassName, containerStyle, style } = this.props;\n        const { onBlur, onChange, onClick, onFocus, onKeyDown, onScroll, onSelect, ...restAdditionalTextareaProps } = this.props.additionalTextareaProps || {};\n        let { maxRows } = this.props;\n        const { dataLoading, value } = this.state;\n        if (!this.props.grow)\n            maxRows = 1;\n        // By setting defaultValue to undefined, avoid error:\n        // ForwardRef(TextareaAutosize) contains a textarea with both value and defaultValue props.\n        // Textarea elements must be either controlled or uncontrolled\n        return (React.createElement(\"div\", { className: clsx('rta', containerClassName, {\n                ['rta--loading']: dataLoading,\n            }), style: containerStyle },\n            this.renderSuggestionListContainer(),\n            React.createElement(Textarea, { \"data-testid\": 'message-input', ...this._cleanUpProps(), className: clsx('rta__textarea', className), maxRows: maxRows, onBlur: (e) => {\n                    this._onClickAndBlurHandler(e);\n                    onBlur?.(e);\n                }, onChange: (e) => {\n                    this._changeHandler(e);\n                    onChange?.(e);\n                }, onClick: (e) => {\n                    this._onClickAndBlurHandler(e);\n                    onClick?.(e);\n                }, onCompositionEnd: () => this.setState((pv) => ({ ...pv, isComposing: false })), onCompositionStart: () => this.setState((pv) => ({ ...pv, isComposing: true })), onFocus: (e) => {\n                    this.props.onFocus?.(e);\n                    onFocus?.(e);\n                }, onKeyDown: (e) => {\n                    this._handleKeyDown(e);\n                    onKeyDown?.(e);\n                }, onScroll: (e) => {\n                    this._onScrollHandler(e);\n                    onScroll?.(e);\n                }, onSelect: (e) => {\n                    this._selectHandler(e);\n                    onSelect?.(e);\n                }, ref: (ref) => {\n                    this.props?.innerRef(ref);\n                    this.textareaRef = ref;\n                }, style: style, value: value, ...restAdditionalTextareaProps, defaultValue: undefined })));\n    }\n}\nReactTextareaAutocomplete.defaultProps = {\n    closeOnClickOutside: true,\n    maxRows: 10,\n    minChar: 1,\n    movePopupAsYouType: false,\n    scrollToItem: true,\n    value: '',\n};\nReactTextareaAutocomplete.propTypes = {\n    className: PropTypes.string,\n    closeOnClickOutside: PropTypes.bool,\n    containerClassName: PropTypes.string,\n    containerStyle: PropTypes.object,\n    disableMentions: PropTypes.bool,\n    dropdownClassName: PropTypes.string,\n    dropdownStyle: PropTypes.object,\n    itemClassName: PropTypes.string,\n    itemStyle: PropTypes.object,\n    listClassName: PropTypes.string,\n    listStyle: PropTypes.object,\n    loaderClassName: PropTypes.string,\n    loaderStyle: PropTypes.object,\n    loadingComponent: PropTypes.elementType,\n    minChar: PropTypes.number,\n    onBlur: PropTypes.func,\n    onCaretPositionChange: PropTypes.func,\n    onChange: PropTypes.func,\n    onSelect: PropTypes.func,\n    shouldSubmit: PropTypes.func,\n    style: PropTypes.object,\n    SuggestionList: PropTypes.elementType,\n    trigger: triggerPropsCheck,\n    value: PropTypes.string,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}