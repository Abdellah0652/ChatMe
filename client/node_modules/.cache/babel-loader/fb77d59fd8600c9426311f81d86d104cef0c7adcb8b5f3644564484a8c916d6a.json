{"ast":null,"code":"/* eslint-disable no-continue */\nimport { nanoid } from 'nanoid';\nimport { CUSTOM_MESSAGE_TYPE } from '../../constants/messageTypes';\nimport { isMessageEdited } from '../Message/utils';\nimport { isDate } from '../../i18n';\n/**\n * processMessages - Transform the input message list according to config parameters\n *\n * Inserts date separators btw. messages created on different dates or before unread incoming messages. By default:\n * - enabled in main message list\n * - disabled in virtualized message list\n * - disabled in thread\n *\n * Allows to filter out deleted messages, contolled by hideDeletedMessages param. This is disabled by default.\n *\n * Sets Giphy preview message for VirtualizedMessageList\n *\n * The only required params are messages and userId, the rest are config params:\n *\n * @return {StreamMessage<StreamChatGenerics>[]} Transformed list of messages\n */\nexport const processMessages = params => {\n  const {\n    messages,\n    reviewProcessedMessage,\n    setGiphyPreviewMessage,\n    ...context\n  } = params;\n  const {\n    enableDateSeparator,\n    hideDeletedMessages,\n    hideNewMessageSeparator,\n    lastRead,\n    userId\n  } = context;\n  let unread = false;\n  let ephemeralMessagePresent = false;\n  let lastDateSeparator;\n  const newMessages = [];\n  for (let i = 0; i < messages.length; i += 1) {\n    const message = messages[i];\n    if (hideDeletedMessages && message.type === 'deleted') {\n      continue;\n    }\n    if (setGiphyPreviewMessage && message.type === 'ephemeral' && message.command === 'giphy') {\n      ephemeralMessagePresent = true;\n      setGiphyPreviewMessage(message);\n      continue;\n    }\n    const changes = [];\n    const messageDate = message.created_at && isDate(message.created_at) && message.created_at.toDateString() || '';\n    const previousMessage = messages[i - 1];\n    let prevMessageDate = messageDate;\n    if (enableDateSeparator && previousMessage?.created_at && isDate(previousMessage.created_at)) {\n      prevMessageDate = previousMessage.created_at.toDateString();\n    }\n    if (!unread && !hideNewMessageSeparator) {\n      unread = lastRead && message.created_at && new Date(lastRead) < message.created_at || false;\n      // do not show date separator for current user's messages\n      if (enableDateSeparator && unread && message.user?.id !== userId) {\n        changes.push({\n          customType: CUSTOM_MESSAGE_TYPE.date,\n          date: message.created_at,\n          id: makeDateMessageId(message.created_at),\n          unread\n        });\n      }\n    }\n    if (enableDateSeparator && (i === 0 ||\n    // always put date separator before the first message\n    messageDate !== prevMessageDate ||\n    // add date separator btw. 2 messages created on different date\n    // if hiding deleted messages replace the previous deleted message(s) with A separator if the last rendered message was created on different date\n    hideDeletedMessages && previousMessage?.type === 'deleted' && lastDateSeparator !== messageDate) && changes[changes.length - 1]?.customType !== CUSTOM_MESSAGE_TYPE.date // do not show two date separators in a row)\n    ) {\n      lastDateSeparator = messageDate;\n      changes.push({\n        customType: CUSTOM_MESSAGE_TYPE.date,\n        date: message.created_at,\n        id: makeDateMessageId(message.created_at)\n      }, message);\n    } else {\n      changes.push(message);\n    }\n    newMessages.push(...(reviewProcessedMessage?.({\n      changes,\n      context,\n      index: i,\n      messages,\n      processedMessages: newMessages\n    }) || changes));\n  }\n  // clean up the giphy preview component state after a Cancel action\n  if (setGiphyPreviewMessage && !ephemeralMessagePresent) {\n    setGiphyPreviewMessage(undefined);\n  }\n  return newMessages;\n};\nexport const makeDateMessageId = date => {\n  let idSuffix;\n  try {\n    idSuffix = !date ? nanoid() : date instanceof Date ? date.toISOString() : date;\n  } catch (e) {\n    idSuffix = nanoid();\n  }\n  return `${CUSTOM_MESSAGE_TYPE.date}-${idSuffix}`;\n};\n// fast since it usually iterates just the last few messages\nexport const getLastReceived = messages => {\n  for (let i = messages.length - 1; i > 0; i -= 1) {\n    if (messages[i].status === 'received') {\n      return messages[i].id;\n    }\n  }\n  return null;\n};\nexport const getReadStates = (messages, read = {}, returnAllReadData) => {\n  // create object with empty array for each message id\n  const readData = {};\n  Object.values(read).forEach(readState => {\n    if (!readState.last_read) return;\n    let userLastReadMsgId;\n    // loop messages sent by current user and add read data for other users in channel\n    messages.forEach(msg => {\n      if (msg.created_at && msg.created_at < readState.last_read) {\n        userLastReadMsgId = msg.id;\n        // if true, save other user's read data for all messages they've read\n        if (returnAllReadData) {\n          if (!readData[userLastReadMsgId]) {\n            readData[userLastReadMsgId] = [];\n          }\n          readData[userLastReadMsgId].push(readState.user);\n        }\n      }\n    });\n    // if true, only save read data for other user's last read message\n    if (userLastReadMsgId && !returnAllReadData) {\n      if (!readData[userLastReadMsgId]) {\n        readData[userLastReadMsgId] = [];\n      }\n      readData[userLastReadMsgId].push(readState.user);\n    }\n  });\n  return readData;\n};\nexport const insertIntro = (messages, headerPosition) => {\n  const newMessages = messages;\n  const intro = {\n    customType: CUSTOM_MESSAGE_TYPE.intro\n  };\n  // if no headerPosition is set, HeaderComponent will go at the top\n  if (!headerPosition) {\n    newMessages.unshift(intro);\n    return newMessages;\n  }\n  // if no messages, intro gets inserted\n  if (!newMessages.length) {\n    newMessages.unshift(intro);\n    return newMessages;\n  }\n  // else loop over the messages\n  for (let i = 0; i < messages.length; i += 1) {\n    const message = messages[i];\n    const messageTime = message.created_at && isDate(message.created_at) ? message.created_at.getTime() : null;\n    const nextMessage = messages[i + 1];\n    const nextMessageTime = nextMessage.created_at && isDate(nextMessage.created_at) ? nextMessage.created_at.getTime() : null;\n    // header position is smaller than message time so comes after;\n    if (messageTime && messageTime < headerPosition) {\n      // if header position is also smaller than message time continue;\n      if (nextMessageTime && nextMessageTime < headerPosition) {\n        if (messages[i + 1] && messages[i + 1].customType === CUSTOM_MESSAGE_TYPE.date) continue;\n        if (!nextMessageTime) {\n          newMessages.push(intro);\n          return newMessages;\n        }\n      } else {\n        newMessages.splice(i + 1, 0, intro);\n        return newMessages;\n      }\n    }\n  }\n  return newMessages;\n};\nexport const getGroupStyles = (message, previousMessage, nextMessage, noGroupByUser, maxTimeBetweenGroupedMessages) => {\n  if (message.customType === CUSTOM_MESSAGE_TYPE.date) return '';\n  if (message.customType === CUSTOM_MESSAGE_TYPE.intro) return '';\n  if (noGroupByUser || message.attachments?.length !== 0) return 'single';\n  const isTopMessage = !previousMessage || previousMessage.customType === CUSTOM_MESSAGE_TYPE.intro || previousMessage.customType === CUSTOM_MESSAGE_TYPE.date || previousMessage.type === 'system' || previousMessage.type === 'error' || previousMessage.attachments?.length !== 0 || message.user?.id !== previousMessage.user?.id || previousMessage.deleted_at || message.reaction_groups && Object.keys(message.reaction_groups).length > 0 || isMessageEdited(previousMessage) || maxTimeBetweenGroupedMessages !== undefined && previousMessage.created_at && message.created_at && new Date(message.created_at).getTime() - new Date(previousMessage.created_at).getTime() > maxTimeBetweenGroupedMessages;\n  const isBottomMessage = !nextMessage || nextMessage.customType === CUSTOM_MESSAGE_TYPE.intro || nextMessage.customType === CUSTOM_MESSAGE_TYPE.date || nextMessage.type === 'system' || nextMessage.type === 'error' || nextMessage.attachments?.length !== 0 || message.user?.id !== nextMessage.user?.id || nextMessage.deleted_at || nextMessage.reaction_groups && Object.keys(nextMessage.reaction_groups).length > 0 || isMessageEdited(message) || maxTimeBetweenGroupedMessages !== undefined && nextMessage.created_at && message.created_at && new Date(nextMessage.created_at).getTime() - new Date(message.created_at).getTime() > maxTimeBetweenGroupedMessages;\n  if (!isTopMessage && !isBottomMessage) {\n    if (message.deleted_at || message.type === 'error') return 'single';\n    return 'middle';\n  }\n  if (isBottomMessage) {\n    if (isTopMessage || message.deleted_at || message.type === 'error') return 'single';\n    return 'bottom';\n  }\n  if (isTopMessage) return 'top';\n  return '';\n};\n// \"Probably\" included, because it may happen that the last page was returned and it has exactly the size of the limit\n// but the back-end cannot provide us with information on whether it has still more messages in the DB\n// FIXME: once the pagination state is moved from Channel to MessageList, these should be moved as well.\n//  The MessageList should have configurable the limit for performing the requests.\n//  This parameter would then be used within these functions\nexport const hasMoreMessagesProbably = (returnedCountMessages, limit) => returnedCountMessages >= limit;\n// @deprecated\nexport const hasNotMoreMessages = (returnedCountMessages, limit) => returnedCountMessages < limit;\nexport function isDateSeparatorMessage(message) {\n  return message.customType === CUSTOM_MESSAGE_TYPE.date && !!message.date && isDate(message.date);\n}","map":{"version":3,"names":["nanoid","CUSTOM_MESSAGE_TYPE","isMessageEdited","isDate","processMessages","params","messages","reviewProcessedMessage","setGiphyPreviewMessage","context","enableDateSeparator","hideDeletedMessages","hideNewMessageSeparator","lastRead","userId","unread","ephemeralMessagePresent","lastDateSeparator","newMessages","i","length","message","type","command","changes","messageDate","created_at","toDateString","previousMessage","prevMessageDate","Date","user","id","push","customType","date","makeDateMessageId","index","processedMessages","undefined","idSuffix","toISOString","e","getLastReceived","status","getReadStates","read","returnAllReadData","readData","Object","values","forEach","readState","last_read","userLastReadMsgId","msg","insertIntro","headerPosition","intro","unshift","messageTime","getTime","nextMessage","nextMessageTime","splice","getGroupStyles","noGroupByUser","maxTimeBetweenGroupedMessages","attachments","isTopMessage","deleted_at","reaction_groups","keys","isBottomMessage","hasMoreMessagesProbably","returnedCountMessages","limit","hasNotMoreMessages","isDateSeparatorMessage"],"sources":["C:/Users/abdel/OneDrive/Desktop/Medical-plager/client/node_modules/stream-chat-react/dist/components/MessageList/utils.js"],"sourcesContent":["/* eslint-disable no-continue */\nimport { nanoid } from 'nanoid';\nimport { CUSTOM_MESSAGE_TYPE } from '../../constants/messageTypes';\nimport { isMessageEdited } from '../Message/utils';\nimport { isDate } from '../../i18n';\n/**\n * processMessages - Transform the input message list according to config parameters\n *\n * Inserts date separators btw. messages created on different dates or before unread incoming messages. By default:\n * - enabled in main message list\n * - disabled in virtualized message list\n * - disabled in thread\n *\n * Allows to filter out deleted messages, contolled by hideDeletedMessages param. This is disabled by default.\n *\n * Sets Giphy preview message for VirtualizedMessageList\n *\n * The only required params are messages and userId, the rest are config params:\n *\n * @return {StreamMessage<StreamChatGenerics>[]} Transformed list of messages\n */\nexport const processMessages = (params) => {\n    const { messages, reviewProcessedMessage, setGiphyPreviewMessage, ...context } = params;\n    const { enableDateSeparator, hideDeletedMessages, hideNewMessageSeparator, lastRead, userId, } = context;\n    let unread = false;\n    let ephemeralMessagePresent = false;\n    let lastDateSeparator;\n    const newMessages = [];\n    for (let i = 0; i < messages.length; i += 1) {\n        const message = messages[i];\n        if (hideDeletedMessages && message.type === 'deleted') {\n            continue;\n        }\n        if (setGiphyPreviewMessage && message.type === 'ephemeral' && message.command === 'giphy') {\n            ephemeralMessagePresent = true;\n            setGiphyPreviewMessage(message);\n            continue;\n        }\n        const changes = [];\n        const messageDate = (message.created_at && isDate(message.created_at) && message.created_at.toDateString()) || '';\n        const previousMessage = messages[i - 1];\n        let prevMessageDate = messageDate;\n        if (enableDateSeparator && previousMessage?.created_at && isDate(previousMessage.created_at)) {\n            prevMessageDate = previousMessage.created_at.toDateString();\n        }\n        if (!unread && !hideNewMessageSeparator) {\n            unread = (lastRead && message.created_at && new Date(lastRead) < message.created_at) || false;\n            // do not show date separator for current user's messages\n            if (enableDateSeparator && unread && message.user?.id !== userId) {\n                changes.push({\n                    customType: CUSTOM_MESSAGE_TYPE.date,\n                    date: message.created_at,\n                    id: makeDateMessageId(message.created_at),\n                    unread,\n                });\n            }\n        }\n        if (enableDateSeparator &&\n            (i === 0 || // always put date separator before the first message\n                messageDate !== prevMessageDate || // add date separator btw. 2 messages created on different date\n                // if hiding deleted messages replace the previous deleted message(s) with A separator if the last rendered message was created on different date\n                (hideDeletedMessages &&\n                    previousMessage?.type === 'deleted' &&\n                    lastDateSeparator !== messageDate)) &&\n            changes[changes.length - 1]?.customType !== CUSTOM_MESSAGE_TYPE.date // do not show two date separators in a row)\n        ) {\n            lastDateSeparator = messageDate;\n            changes.push({\n                customType: CUSTOM_MESSAGE_TYPE.date,\n                date: message.created_at,\n                id: makeDateMessageId(message.created_at),\n            }, message);\n        }\n        else {\n            changes.push(message);\n        }\n        newMessages.push(...(reviewProcessedMessage?.({\n            changes,\n            context,\n            index: i,\n            messages,\n            processedMessages: newMessages,\n        }) || changes));\n    }\n    // clean up the giphy preview component state after a Cancel action\n    if (setGiphyPreviewMessage && !ephemeralMessagePresent) {\n        setGiphyPreviewMessage(undefined);\n    }\n    return newMessages;\n};\nexport const makeDateMessageId = (date) => {\n    let idSuffix;\n    try {\n        idSuffix = !date ? nanoid() : date instanceof Date ? date.toISOString() : date;\n    }\n    catch (e) {\n        idSuffix = nanoid();\n    }\n    return `${CUSTOM_MESSAGE_TYPE.date}-${idSuffix}`;\n};\n// fast since it usually iterates just the last few messages\nexport const getLastReceived = (messages) => {\n    for (let i = messages.length - 1; i > 0; i -= 1) {\n        if (messages[i].status === 'received') {\n            return messages[i].id;\n        }\n    }\n    return null;\n};\nexport const getReadStates = (messages, read = {}, returnAllReadData) => {\n    // create object with empty array for each message id\n    const readData = {};\n    Object.values(read).forEach((readState) => {\n        if (!readState.last_read)\n            return;\n        let userLastReadMsgId;\n        // loop messages sent by current user and add read data for other users in channel\n        messages.forEach((msg) => {\n            if (msg.created_at && msg.created_at < readState.last_read) {\n                userLastReadMsgId = msg.id;\n                // if true, save other user's read data for all messages they've read\n                if (returnAllReadData) {\n                    if (!readData[userLastReadMsgId]) {\n                        readData[userLastReadMsgId] = [];\n                    }\n                    readData[userLastReadMsgId].push(readState.user);\n                }\n            }\n        });\n        // if true, only save read data for other user's last read message\n        if (userLastReadMsgId && !returnAllReadData) {\n            if (!readData[userLastReadMsgId]) {\n                readData[userLastReadMsgId] = [];\n            }\n            readData[userLastReadMsgId].push(readState.user);\n        }\n    });\n    return readData;\n};\nexport const insertIntro = (messages, headerPosition) => {\n    const newMessages = messages;\n    const intro = {\n        customType: CUSTOM_MESSAGE_TYPE.intro,\n    };\n    // if no headerPosition is set, HeaderComponent will go at the top\n    if (!headerPosition) {\n        newMessages.unshift(intro);\n        return newMessages;\n    }\n    // if no messages, intro gets inserted\n    if (!newMessages.length) {\n        newMessages.unshift(intro);\n        return newMessages;\n    }\n    // else loop over the messages\n    for (let i = 0; i < messages.length; i += 1) {\n        const message = messages[i];\n        const messageTime = message.created_at && isDate(message.created_at) ? message.created_at.getTime() : null;\n        const nextMessage = messages[i + 1];\n        const nextMessageTime = nextMessage.created_at && isDate(nextMessage.created_at)\n            ? nextMessage.created_at.getTime()\n            : null;\n        // header position is smaller than message time so comes after;\n        if (messageTime && messageTime < headerPosition) {\n            // if header position is also smaller than message time continue;\n            if (nextMessageTime && nextMessageTime < headerPosition) {\n                if (messages[i + 1] && messages[i + 1].customType === CUSTOM_MESSAGE_TYPE.date)\n                    continue;\n                if (!nextMessageTime) {\n                    newMessages.push(intro);\n                    return newMessages;\n                }\n            }\n            else {\n                newMessages.splice(i + 1, 0, intro);\n                return newMessages;\n            }\n        }\n    }\n    return newMessages;\n};\nexport const getGroupStyles = (message, previousMessage, nextMessage, noGroupByUser, maxTimeBetweenGroupedMessages) => {\n    if (message.customType === CUSTOM_MESSAGE_TYPE.date)\n        return '';\n    if (message.customType === CUSTOM_MESSAGE_TYPE.intro)\n        return '';\n    if (noGroupByUser || message.attachments?.length !== 0)\n        return 'single';\n    const isTopMessage = !previousMessage ||\n        previousMessage.customType === CUSTOM_MESSAGE_TYPE.intro ||\n        previousMessage.customType === CUSTOM_MESSAGE_TYPE.date ||\n        previousMessage.type === 'system' ||\n        previousMessage.type === 'error' ||\n        previousMessage.attachments?.length !== 0 ||\n        message.user?.id !== previousMessage.user?.id ||\n        previousMessage.deleted_at ||\n        (message.reaction_groups && Object.keys(message.reaction_groups).length > 0) ||\n        isMessageEdited(previousMessage) ||\n        (maxTimeBetweenGroupedMessages !== undefined &&\n            previousMessage.created_at &&\n            message.created_at &&\n            new Date(message.created_at).getTime() - new Date(previousMessage.created_at).getTime() >\n                maxTimeBetweenGroupedMessages);\n    const isBottomMessage = !nextMessage ||\n        nextMessage.customType === CUSTOM_MESSAGE_TYPE.intro ||\n        nextMessage.customType === CUSTOM_MESSAGE_TYPE.date ||\n        nextMessage.type === 'system' ||\n        nextMessage.type === 'error' ||\n        nextMessage.attachments?.length !== 0 ||\n        message.user?.id !== nextMessage.user?.id ||\n        nextMessage.deleted_at ||\n        (nextMessage.reaction_groups && Object.keys(nextMessage.reaction_groups).length > 0) ||\n        isMessageEdited(message) ||\n        (maxTimeBetweenGroupedMessages !== undefined &&\n            nextMessage.created_at &&\n            message.created_at &&\n            new Date(nextMessage.created_at).getTime() - new Date(message.created_at).getTime() >\n                maxTimeBetweenGroupedMessages);\n    if (!isTopMessage && !isBottomMessage) {\n        if (message.deleted_at || message.type === 'error')\n            return 'single';\n        return 'middle';\n    }\n    if (isBottomMessage) {\n        if (isTopMessage || message.deleted_at || message.type === 'error')\n            return 'single';\n        return 'bottom';\n    }\n    if (isTopMessage)\n        return 'top';\n    return '';\n};\n// \"Probably\" included, because it may happen that the last page was returned and it has exactly the size of the limit\n// but the back-end cannot provide us with information on whether it has still more messages in the DB\n// FIXME: once the pagination state is moved from Channel to MessageList, these should be moved as well.\n//  The MessageList should have configurable the limit for performing the requests.\n//  This parameter would then be used within these functions\nexport const hasMoreMessagesProbably = (returnedCountMessages, limit) => returnedCountMessages >= limit;\n// @deprecated\nexport const hasNotMoreMessages = (returnedCountMessages, limit) => returnedCountMessages < limit;\nexport function isDateSeparatorMessage(message) {\n    return message.customType === CUSTOM_MESSAGE_TYPE.date && !!message.date && isDate(message.date);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}