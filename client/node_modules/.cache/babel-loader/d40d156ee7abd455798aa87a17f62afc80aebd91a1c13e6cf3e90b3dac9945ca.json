{"ast":null,"code":"import { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport uniqBy from 'lodash.uniqby';\nimport { MAX_QUERY_CHANNELS_LIMIT } from '../utils';\nimport { useChatContext } from '../../../context/ChatContext';\nimport { DEFAULT_INITIAL_CHANNEL_PAGE_SIZE } from '../../../constants/limits';\nconst RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS = 5000;\nconst MIN_RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS = 2000;\nexport const usePaginatedChannels = (client, filters, sort, options, activeChannelHandler, recoveryThrottleIntervalMs = RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS, customQueryChannels) => {\n  const {\n    channelsQueryState: {\n      error,\n      setError,\n      setQueryInProgress\n    }\n  } = useChatContext('usePaginatedChannels');\n  const [channels, setChannels] = useState([]);\n  const [hasNextPage, setHasNextPage] = useState(true);\n  const lastRecoveryTimestamp = useRef();\n  const recoveryThrottleInterval = recoveryThrottleIntervalMs < MIN_RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS ? MIN_RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS : recoveryThrottleIntervalMs ?? RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS;\n  // memoize props\n  const filterString = useMemo(() => JSON.stringify(filters), [filters]);\n  const sortString = useMemo(() => JSON.stringify(sort), [sort]);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const queryChannels = async (queryType = 'load-more') => {\n    setError(null);\n    if (queryType === 'reload') {\n      setChannels([]);\n    }\n    setQueryInProgress(queryType);\n    try {\n      if (customQueryChannels) {\n        await customQueryChannels({\n          currentChannels: channels,\n          queryType: queryType,\n          setChannels,\n          setHasNextPage\n        });\n      } else {\n        const offset = queryType === 'reload' ? 0 : channels.length;\n        const newOptions = {\n          limit: options?.limit ?? MAX_QUERY_CHANNELS_LIMIT,\n          message_limit: options?.message_limit ?? DEFAULT_INITIAL_CHANNEL_PAGE_SIZE,\n          offset,\n          ...options\n        };\n        const channelQueryResponse = await client.queryChannels(filters, sort || {}, newOptions);\n        const newChannels = queryType === 'reload' ? channelQueryResponse : uniqBy([...channels, ...channelQueryResponse], 'cid');\n        setChannels(newChannels);\n        setHasNextPage(channelQueryResponse.length >= newOptions.limit);\n        // Set active channel only on load of first page\n        if (!offset && activeChannelHandler) {\n          activeChannelHandler(newChannels, setChannels);\n        }\n      }\n    } catch (err) {\n      console.warn(err);\n      setError(err);\n    }\n    setQueryInProgress(null);\n  };\n  const throttleRecover = useCallback(() => {\n    const now = Date.now();\n    const isFirstRecovery = !lastRecoveryTimestamp.current;\n    const timeElapsedSinceLastRecoveryMs = lastRecoveryTimestamp.current ? now - lastRecoveryTimestamp.current : 0;\n    if (!isFirstRecovery && timeElapsedSinceLastRecoveryMs < recoveryThrottleInterval && !error) {\n      return;\n    }\n    lastRecoveryTimestamp.current = now;\n    queryChannels('reload');\n  }, [error, queryChannels, recoveryThrottleInterval]);\n  const loadNextPage = () => {\n    queryChannels();\n  };\n  useEffect(() => {\n    if (client.recoverStateOnReconnect) return;\n    const {\n      unsubscribe\n    } = client.on('connection.recovered', throttleRecover);\n    return () => {\n      unsubscribe();\n    };\n  }, [client, throttleRecover]);\n  useEffect(() => {\n    queryChannels('reload');\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [filterString, sortString]);\n  return {\n    channels,\n    hasNextPage,\n    loadNextPage,\n    setChannels\n  };\n};","map":{"version":3,"names":["useCallback","useEffect","useMemo","useRef","useState","uniqBy","MAX_QUERY_CHANNELS_LIMIT","useChatContext","DEFAULT_INITIAL_CHANNEL_PAGE_SIZE","RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS","MIN_RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS","usePaginatedChannels","client","filters","sort","options","activeChannelHandler","recoveryThrottleIntervalMs","customQueryChannels","channelsQueryState","error","setError","setQueryInProgress","channels","setChannels","hasNextPage","setHasNextPage","lastRecoveryTimestamp","recoveryThrottleInterval","filterString","JSON","stringify","sortString","queryChannels","queryType","currentChannels","offset","length","newOptions","limit","message_limit","channelQueryResponse","newChannels","err","console","warn","throttleRecover","now","Date","isFirstRecovery","current","timeElapsedSinceLastRecoveryMs","loadNextPage","recoverStateOnReconnect","unsubscribe","on"],"sources":["C:/Users/abdel/OneDrive/Desktop/Medical-plager/client/node_modules/stream-chat-react/dist/components/ChannelList/hooks/usePaginatedChannels.js"],"sourcesContent":["import { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport uniqBy from 'lodash.uniqby';\nimport { MAX_QUERY_CHANNELS_LIMIT } from '../utils';\nimport { useChatContext } from '../../../context/ChatContext';\nimport { DEFAULT_INITIAL_CHANNEL_PAGE_SIZE } from '../../../constants/limits';\nconst RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS = 5000;\nconst MIN_RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS = 2000;\nexport const usePaginatedChannels = (client, filters, sort, options, activeChannelHandler, recoveryThrottleIntervalMs = RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS, customQueryChannels) => {\n    const { channelsQueryState: { error, setError, setQueryInProgress }, } = useChatContext('usePaginatedChannels');\n    const [channels, setChannels] = useState([]);\n    const [hasNextPage, setHasNextPage] = useState(true);\n    const lastRecoveryTimestamp = useRef();\n    const recoveryThrottleInterval = recoveryThrottleIntervalMs < MIN_RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS\n        ? MIN_RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS\n        : recoveryThrottleIntervalMs ?? RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS;\n    // memoize props\n    const filterString = useMemo(() => JSON.stringify(filters), [filters]);\n    const sortString = useMemo(() => JSON.stringify(sort), [sort]);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const queryChannels = async (queryType = 'load-more') => {\n        setError(null);\n        if (queryType === 'reload') {\n            setChannels([]);\n        }\n        setQueryInProgress(queryType);\n        try {\n            if (customQueryChannels) {\n                await customQueryChannels({\n                    currentChannels: channels,\n                    queryType: queryType,\n                    setChannels,\n                    setHasNextPage,\n                });\n            }\n            else {\n                const offset = queryType === 'reload' ? 0 : channels.length;\n                const newOptions = {\n                    limit: options?.limit ?? MAX_QUERY_CHANNELS_LIMIT,\n                    message_limit: options?.message_limit ?? DEFAULT_INITIAL_CHANNEL_PAGE_SIZE,\n                    offset,\n                    ...options,\n                };\n                const channelQueryResponse = await client.queryChannels(filters, sort || {}, newOptions);\n                const newChannels = queryType === 'reload'\n                    ? channelQueryResponse\n                    : uniqBy([...channels, ...channelQueryResponse], 'cid');\n                setChannels(newChannels);\n                setHasNextPage(channelQueryResponse.length >= newOptions.limit);\n                // Set active channel only on load of first page\n                if (!offset && activeChannelHandler) {\n                    activeChannelHandler(newChannels, setChannels);\n                }\n            }\n        }\n        catch (err) {\n            console.warn(err);\n            setError(err);\n        }\n        setQueryInProgress(null);\n    };\n    const throttleRecover = useCallback(() => {\n        const now = Date.now();\n        const isFirstRecovery = !lastRecoveryTimestamp.current;\n        const timeElapsedSinceLastRecoveryMs = lastRecoveryTimestamp.current\n            ? now - lastRecoveryTimestamp.current\n            : 0;\n        if (!isFirstRecovery && timeElapsedSinceLastRecoveryMs < recoveryThrottleInterval && !error) {\n            return;\n        }\n        lastRecoveryTimestamp.current = now;\n        queryChannels('reload');\n    }, [error, queryChannels, recoveryThrottleInterval]);\n    const loadNextPage = () => {\n        queryChannels();\n    };\n    useEffect(() => {\n        if (client.recoverStateOnReconnect)\n            return;\n        const { unsubscribe } = client.on('connection.recovered', throttleRecover);\n        return () => {\n            unsubscribe();\n        };\n    }, [client, throttleRecover]);\n    useEffect(() => {\n        queryChannels('reload');\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [filterString, sortString]);\n    return {\n        channels,\n        hasNextPage,\n        loadNextPage,\n        setChannels,\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}