{"ast":null,"code":"import React, { useCallback, useEffect, useLayoutEffect, useMemo, useReducer, useRef, useState } from 'react';\nimport debounce from 'lodash.debounce';\nimport defaultsDeep from 'lodash.defaultsdeep';\nimport throttle from 'lodash.throttle';\nimport { nanoid } from 'nanoid';\nimport clsx from 'clsx';\nimport { channelReducer, initialState } from './channelState';\nimport { useCreateChannelStateContext } from './hooks/useCreateChannelStateContext';\nimport { useCreateTypingContext } from './hooks/useCreateTypingContext';\nimport { useEditMessageHandler } from './hooks/useEditMessageHandler';\nimport { useIsMounted } from './hooks/useIsMounted';\nimport { useMentionsHandlers } from './hooks/useMentionsHandlers';\nimport { LoadingErrorIndicator as DefaultLoadingErrorIndicator } from '../Loading';\nimport { LoadingChannel as DefaultLoadingIndicator } from './LoadingChannel';\nimport { DropzoneProvider } from '../MessageInput/DropzoneProvider';\nimport { ChannelActionProvider, ChannelStateProvider, TypingProvider, useChatContext, useTranslationContext, WithComponents } from '../../context';\nimport { DEFAULT_HIGHLIGHT_DURATION, DEFAULT_INITIAL_CHANNEL_PAGE_SIZE, DEFAULT_JUMP_TO_PAGE_SIZE, DEFAULT_NEXT_CHANNEL_PAGE_SIZE, DEFAULT_THREAD_PAGE_SIZE } from '../../constants/limits';\nimport { hasMoreMessagesProbably } from '../MessageList';\nimport { getChatContainerClass, useChannelContainerClasses, useImageFlagEmojisOnWindowsClass } from './hooks/useChannelContainerClasses';\nimport { findInMsgSetByDate, findInMsgSetById, makeAddNotifications } from './utils';\nimport { getChannel } from '../../utils';\nimport { getImageAttachmentConfiguration, getVideoAttachmentConfiguration } from '../Attachment/attachment-sizing';\nimport { useThreadContext } from '../Threads';\nimport { CHANNEL_CONTAINER_ID } from './constants';\nconst isUserResponseArray = output => output[0]?.id != null;\nconst ChannelContainer = ({\n  children,\n  className: additionalClassName,\n  ...props\n}) => {\n  const {\n    customClasses,\n    theme\n  } = useChatContext('Channel');\n  const {\n    channelClass,\n    chatClass\n  } = useChannelContainerClasses({\n    customClasses\n  });\n  const className = clsx(chatClass, theme, channelClass, additionalClassName);\n  return React.createElement(\"div\", {\n    id: CHANNEL_CONTAINER_ID,\n    ...props,\n    className: className\n  }, children);\n};\nconst UnMemoizedChannel = props => {\n  const {\n    channel: propsChannel,\n    EmptyPlaceholder = null,\n    LoadingErrorIndicator,\n    LoadingIndicator = DefaultLoadingIndicator\n  } = props;\n  const {\n    channel: contextChannel,\n    channelsQueryState\n  } = useChatContext('Channel');\n  const channel = propsChannel || contextChannel;\n  if (channelsQueryState.queryInProgress === 'reload' && LoadingIndicator) {\n    return React.createElement(ChannelContainer, null, React.createElement(LoadingIndicator, null));\n  }\n  if (channelsQueryState.error && LoadingErrorIndicator) {\n    return React.createElement(ChannelContainer, null, React.createElement(LoadingErrorIndicator, {\n      error: channelsQueryState.error\n    }));\n  }\n  if (!channel?.cid) {\n    return React.createElement(ChannelContainer, null, EmptyPlaceholder);\n  }\n  return React.createElement(ChannelInner, {\n    ...props,\n    channel: channel,\n    key: channel.cid\n  });\n};\nconst ChannelInner = props => {\n  const {\n    acceptedFiles,\n    activeUnreadHandler,\n    channel,\n    channelQueryOptions: propChannelQueryOptions,\n    children,\n    doDeleteMessageRequest,\n    doMarkReadRequest,\n    doSendMessageRequest,\n    doUpdateMessageRequest,\n    dragAndDropWindow = false,\n    enrichURLForPreviewConfig,\n    initializeOnMount = true,\n    LoadingErrorIndicator = DefaultLoadingErrorIndicator,\n    LoadingIndicator = DefaultLoadingIndicator,\n    markReadOnMount = true,\n    maxNumberOfFiles,\n    multipleUploads = true,\n    onMentionsClick,\n    onMentionsHover,\n    optionalMessageInputProps = {},\n    skipMessageDataMemoization\n  } = props;\n  const channelQueryOptions = useMemo(() => defaultsDeep(propChannelQueryOptions, {\n    messages: {\n      limit: DEFAULT_INITIAL_CHANNEL_PAGE_SIZE\n    }\n  }), [propChannelQueryOptions]);\n  const {\n    client,\n    customClasses,\n    latestMessageDatesByChannels,\n    mutes\n  } = useChatContext('Channel');\n  const {\n    t\n  } = useTranslationContext('Channel');\n  const chatContainerClass = getChatContainerClass(customClasses?.chatContainer);\n  const windowsEmojiClass = useImageFlagEmojisOnWindowsClass();\n  const thread = useThreadContext();\n  const [channelConfig, setChannelConfig] = useState(channel.getConfig());\n  const [notifications, setNotifications] = useState([]);\n  const [quotedMessage, setQuotedMessage] = useState();\n  const [channelUnreadUiState, _setChannelUnreadUiState] = useState();\n  const notificationTimeouts = useRef([]);\n  const [state, dispatch] = useReducer(channelReducer,\n  // channel.initialized === false if client.channel().query() was not called, e.g. ChannelList is not used\n  // => Channel will call channel.watch() in useLayoutEffect => state.loading is used to signal the watch() call state\n  {\n    ...initialState,\n    hasMore: channel.state.messagePagination.hasPrev,\n    loading: !channel.initialized\n  });\n  const isMounted = useIsMounted();\n  const originalTitle = useRef('');\n  const lastRead = useRef();\n  const online = useRef(true);\n  const channelCapabilitiesArray = channel.data?.own_capabilities;\n  const throttledCopyStateFromChannel = throttle(() => dispatch({\n    channel,\n    type: 'copyStateFromChannelOnEvent'\n  }), 500, {\n    leading: true,\n    trailing: true\n  });\n  const setChannelUnreadUiState = useMemo(() => throttle(_setChannelUnreadUiState, 200, {\n    leading: true,\n    trailing: false\n  }), []);\n  const markRead = useMemo(() => throttle(async options => {\n    const {\n      updateChannelUiUnreadState = true\n    } = options ?? {};\n    if (channel.disconnected || !channelConfig?.read_events) {\n      return;\n    }\n    lastRead.current = new Date();\n    try {\n      if (doMarkReadRequest) {\n        doMarkReadRequest(channel, updateChannelUiUnreadState ? setChannelUnreadUiState : undefined);\n      } else {\n        const markReadResponse = await channel.markRead();\n        if (updateChannelUiUnreadState && markReadResponse) {\n          _setChannelUnreadUiState({\n            last_read: lastRead.current,\n            last_read_message_id: markReadResponse.event.last_read_message_id,\n            unread_messages: 0\n          });\n        }\n      }\n      if (activeUnreadHandler) {\n        activeUnreadHandler(0, originalTitle.current);\n      } else if (originalTitle.current) {\n        document.title = originalTitle.current;\n      }\n    } catch (e) {\n      console.error(t('Failed to mark channel as read'));\n    }\n  }, 500, {\n    leading: true,\n    trailing: false\n  }), [activeUnreadHandler, channel, channelConfig, doMarkReadRequest, setChannelUnreadUiState, t]);\n  const handleEvent = async event => {\n    if (event.message) {\n      dispatch({\n        channel,\n        message: event.message,\n        type: 'updateThreadOnEvent'\n      });\n    }\n    if (event.type === 'user.watching.start' || event.type === 'user.watching.stop') return;\n    if (event.type === 'typing.start' || event.type === 'typing.stop') {\n      return dispatch({\n        channel,\n        type: 'setTyping'\n      });\n    }\n    if (event.type === 'connection.changed' && typeof event.online === 'boolean') {\n      online.current = event.online;\n    }\n    if (event.type === 'message.new') {\n      const mainChannelUpdated = !event.message?.parent_id || event.message?.show_in_channel;\n      if (mainChannelUpdated) {\n        if (document.hidden && channelConfig?.read_events && !channel.muteStatus().muted) {\n          const unread = channel.countUnread(lastRead.current);\n          if (activeUnreadHandler) {\n            activeUnreadHandler(unread, originalTitle.current);\n          } else {\n            document.title = `(${unread}) ${originalTitle.current}`;\n          }\n        }\n      }\n      if (event.message?.user?.id === client.userID && event?.message?.created_at && event?.message?.cid) {\n        const messageDate = new Date(event.message.created_at);\n        const cid = event.message.cid;\n        if (!latestMessageDatesByChannels[cid] || latestMessageDatesByChannels[cid].getTime() < messageDate.getTime()) {\n          latestMessageDatesByChannels[cid] = messageDate;\n        }\n      }\n    }\n    if (event.type === 'user.deleted') {\n      const oldestID = channel.state?.messages?.[0]?.id;\n      /**\n       * As the channel state is not normalized we re-fetch the channel data. Thus, we avoid having to search for user references in the channel state.\n       */\n      // FIXME: we should use channelQueryOptions if they are available\n      await channel.query({\n        messages: {\n          id_lt: oldestID,\n          limit: DEFAULT_NEXT_CHANNEL_PAGE_SIZE\n        },\n        watchers: {\n          limit: DEFAULT_NEXT_CHANNEL_PAGE_SIZE\n        }\n      });\n    }\n    if (event.type === 'notification.mark_unread') _setChannelUnreadUiState(prev => {\n      if (!(event.last_read_at && event.user)) return prev;\n      return {\n        first_unread_message_id: event.first_unread_message_id,\n        last_read: new Date(event.last_read_at),\n        last_read_message_id: event.last_read_message_id,\n        unread_messages: event.unread_messages ?? 0\n      };\n    });\n    if (event.type === 'channel.truncated' && event.cid === channel.cid) {\n      _setChannelUnreadUiState(undefined);\n    }\n    throttledCopyStateFromChannel();\n  };\n  // useLayoutEffect here to prevent spinner. Use Suspense when it is available in stable release\n  useLayoutEffect(() => {\n    let errored = false;\n    let done = false;\n    (async () => {\n      if (!channel.initialized && initializeOnMount) {\n        try {\n          // if active channel has been set without id, we will create a temporary channel id from its member IDs\n          // to keep track of the /query request in progress. This is the same approach of generating temporary id\n          // that the JS client uses to keep track of channel in client.activeChannels\n          const members = [];\n          if (!channel.id && channel.data?.members) {\n            for (const member of channel.data.members) {\n              let userId;\n              if (typeof member === 'string') {\n                userId = member;\n              } else if (typeof member === 'object') {\n                const {\n                  user,\n                  user_id\n                } = member;\n                userId = user_id || user?.id;\n              }\n              if (userId) {\n                members.push(userId);\n              }\n            }\n          }\n          await getChannel({\n            channel,\n            client,\n            members,\n            options: channelQueryOptions\n          });\n          const config = channel.getConfig();\n          setChannelConfig(config);\n        } catch (e) {\n          dispatch({\n            error: e,\n            type: 'setError'\n          });\n          errored = true;\n        }\n      }\n      done = true;\n      originalTitle.current = document.title;\n      if (!errored) {\n        dispatch({\n          channel,\n          hasMore: channel.state.messagePagination.hasPrev,\n          type: 'initStateFromChannel'\n        });\n        if (client.user?.id && channel.state.read[client.user.id]) {\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const {\n            user,\n            ...ownReadState\n          } = channel.state.read[client.user.id];\n          _setChannelUnreadUiState(ownReadState);\n        }\n        /**\n         * TODO: maybe pass last_read to the countUnread method to get proper value\n         * combined with channel.countUnread adjustment (_countMessageAsUnread)\n         * to allow counting own messages too\n         *\n         * const lastRead = channel.state.read[client.userID as string].last_read;\n         */\n        if (channel.countUnread() > 0 && markReadOnMount) markRead({\n          updateChannelUiUnreadState: false\n        });\n        // The more complex sync logic is done in Chat\n        client.on('connection.changed', handleEvent);\n        client.on('connection.recovered', handleEvent);\n        client.on('user.updated', handleEvent);\n        client.on('user.deleted', handleEvent);\n        channel.on(handleEvent);\n      }\n    })();\n    const notificationTimeoutsRef = notificationTimeouts.current;\n    return () => {\n      if (errored || !done) return;\n      channel?.off(handleEvent);\n      client.off('connection.changed', handleEvent);\n      client.off('connection.recovered', handleEvent);\n      client.off('user.deleted', handleEvent);\n      notificationTimeoutsRef.forEach(clearTimeout);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [channel.cid, channelQueryOptions, doMarkReadRequest, channelConfig?.read_events, initializeOnMount]);\n  useEffect(() => {\n    if (!state.thread) return;\n    const message = state.messages?.find(m => m.id === state.thread?.id);\n    if (message) dispatch({\n      message,\n      type: 'setThread'\n    });\n  }, [state.messages, state.thread]);\n  /** MESSAGE */\n  // Adds a temporary notification to message list, will be removed after 5 seconds\n  const addNotification = useMemo(() => makeAddNotifications(setNotifications, notificationTimeouts.current), []);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const loadMoreFinished = useCallback(debounce((hasMore, messages) => {\n    if (!isMounted.current) return;\n    dispatch({\n      hasMore,\n      messages,\n      type: 'loadMoreFinished'\n    });\n  }, 2000, {\n    leading: true,\n    trailing: true\n  }), []);\n  const loadMore = async (limit = DEFAULT_NEXT_CHANNEL_PAGE_SIZE) => {\n    if (!online.current || !window.navigator.onLine || !channel.state.messagePagination.hasPrev) return 0;\n    // prevent duplicate loading events...\n    const oldestMessage = state?.messages?.[0];\n    if (state.loadingMore || state.loadingMoreNewer || oldestMessage?.status !== 'received') {\n      return 0;\n    }\n    dispatch({\n      loadingMore: true,\n      type: 'setLoadingMore'\n    });\n    const oldestID = oldestMessage?.id;\n    const perPage = limit;\n    let queryResponse;\n    try {\n      queryResponse = await channel.query({\n        messages: {\n          id_lt: oldestID,\n          limit: perPage\n        },\n        watchers: {\n          limit: perPage\n        }\n      });\n    } catch (e) {\n      console.warn('message pagination request failed with error', e);\n      dispatch({\n        loadingMore: false,\n        type: 'setLoadingMore'\n      });\n      return 0;\n    }\n    loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n    return queryResponse.messages.length;\n  };\n  const loadMoreNewer = async (limit = DEFAULT_NEXT_CHANNEL_PAGE_SIZE) => {\n    if (!online.current || !window.navigator.onLine || !channel.state.messagePagination.hasNext) return 0;\n    const newestMessage = state?.messages?.[state?.messages?.length - 1];\n    if (state.loadingMore || state.loadingMoreNewer) return 0;\n    dispatch({\n      loadingMoreNewer: true,\n      type: 'setLoadingMoreNewer'\n    });\n    const newestId = newestMessage?.id;\n    const perPage = limit;\n    let queryResponse;\n    try {\n      queryResponse = await channel.query({\n        messages: {\n          id_gt: newestId,\n          limit: perPage\n        },\n        watchers: {\n          limit: perPage\n        }\n      });\n    } catch (e) {\n      console.warn('message pagination request failed with error', e);\n      dispatch({\n        loadingMoreNewer: false,\n        type: 'setLoadingMoreNewer'\n      });\n      return 0;\n    }\n    dispatch({\n      hasMoreNewer: channel.state.messagePagination.hasNext,\n      messages: channel.state.messages,\n      type: 'loadMoreNewerFinished'\n    });\n    return queryResponse.messages.length;\n  };\n  const clearHighlightedMessageTimeoutId = useRef(null);\n  const jumpToMessage = useCallback(async (messageId, messageLimit = DEFAULT_JUMP_TO_PAGE_SIZE, highlightDuration = DEFAULT_HIGHLIGHT_DURATION) => {\n    dispatch({\n      loadingMore: true,\n      type: 'setLoadingMore'\n    });\n    await channel.state.loadMessageIntoState(messageId, undefined, messageLimit);\n    loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n    dispatch({\n      hasMoreNewer: channel.state.messagePagination.hasNext,\n      highlightedMessageId: messageId,\n      type: 'jumpToMessageFinished'\n    });\n    if (clearHighlightedMessageTimeoutId.current) {\n      clearTimeout(clearHighlightedMessageTimeoutId.current);\n    }\n    clearHighlightedMessageTimeoutId.current = setTimeout(() => {\n      clearHighlightedMessageTimeoutId.current = null;\n      dispatch({\n        type: 'clearHighlightedMessage'\n      });\n    }, highlightDuration);\n  }, [channel, loadMoreFinished]);\n  const jumpToLatestMessage = useCallback(async () => {\n    await channel.state.loadMessageIntoState('latest');\n    loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n    dispatch({\n      type: 'jumpToLatestMessage'\n    });\n  }, [channel, loadMoreFinished]);\n  const jumpToFirstUnreadMessage = useCallback(async (queryMessageLimit = DEFAULT_JUMP_TO_PAGE_SIZE, highlightDuration = DEFAULT_HIGHLIGHT_DURATION) => {\n    if (!channelUnreadUiState?.unread_messages) return;\n    let lastReadMessageId = channelUnreadUiState?.last_read_message_id;\n    let firstUnreadMessageId = channelUnreadUiState?.first_unread_message_id;\n    let isInCurrentMessageSet = false;\n    if (firstUnreadMessageId) {\n      const result = findInMsgSetById(firstUnreadMessageId, channel.state.messages);\n      isInCurrentMessageSet = result.index !== -1;\n    } else if (lastReadMessageId) {\n      const result = findInMsgSetById(lastReadMessageId, channel.state.messages);\n      isInCurrentMessageSet = !!result.target;\n      firstUnreadMessageId = result.index > -1 ? channel.state.messages[result.index + 1]?.id : undefined;\n    } else {\n      const lastReadTimestamp = channelUnreadUiState.last_read.getTime();\n      const {\n        index: lastReadMessageIndex,\n        target: lastReadMessage\n      } = findInMsgSetByDate(channelUnreadUiState.last_read, channel.state.messages, true);\n      if (lastReadMessage) {\n        firstUnreadMessageId = channel.state.messages[lastReadMessageIndex + 1]?.id;\n        isInCurrentMessageSet = !!firstUnreadMessageId;\n        lastReadMessageId = lastReadMessage.id;\n      } else {\n        dispatch({\n          loadingMore: true,\n          type: 'setLoadingMore'\n        });\n        let messages;\n        try {\n          messages = (await channel.query({\n            messages: {\n              created_at_around: channelUnreadUiState.last_read.toISOString(),\n              limit: queryMessageLimit\n            }\n          }, 'new')).messages;\n        } catch (e) {\n          addNotification(t('Failed to jump to the first unread message'), 'error');\n          loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n          return;\n        }\n        const firstMessageWithCreationDate = messages.find(msg => msg.created_at);\n        if (!firstMessageWithCreationDate) {\n          addNotification(t('Failed to jump to the first unread message'), 'error');\n          loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n          return;\n        }\n        const firstMessageTimestamp = new Date(firstMessageWithCreationDate.created_at).getTime();\n        if (lastReadTimestamp < firstMessageTimestamp) {\n          // whole channel is unread\n          firstUnreadMessageId = firstMessageWithCreationDate.id;\n        } else {\n          const result = findInMsgSetByDate(channelUnreadUiState.last_read, messages);\n          lastReadMessageId = result.target?.id;\n        }\n        loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n      }\n    }\n    if (!firstUnreadMessageId && !lastReadMessageId) {\n      addNotification(t('Failed to jump to the first unread message'), 'error');\n      return;\n    }\n    if (!isInCurrentMessageSet) {\n      dispatch({\n        loadingMore: true,\n        type: 'setLoadingMore'\n      });\n      try {\n        const targetId = firstUnreadMessageId ?? lastReadMessageId;\n        await channel.state.loadMessageIntoState(targetId, undefined, queryMessageLimit);\n        /**\n         * if the index of the last read message on the page is beyond the half of the page,\n         * we have arrived to the oldest page of the channel\n         */\n        const indexOfTarget = channel.state.messages.findIndex(message => message.id === targetId);\n        loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n        firstUnreadMessageId = firstUnreadMessageId ?? channel.state.messages[indexOfTarget + 1]?.id;\n      } catch (e) {\n        addNotification(t('Failed to jump to the first unread message'), 'error');\n        loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n        return;\n      }\n    }\n    if (!firstUnreadMessageId) {\n      addNotification(t('Failed to jump to the first unread message'), 'error');\n      return;\n    }\n    if (!channelUnreadUiState.first_unread_message_id) _setChannelUnreadUiState({\n      ...channelUnreadUiState,\n      first_unread_message_id: firstUnreadMessageId,\n      last_read_message_id: lastReadMessageId\n    });\n    dispatch({\n      hasMoreNewer: channel.state.messagePagination.hasNext,\n      highlightedMessageId: firstUnreadMessageId,\n      type: 'jumpToMessageFinished'\n    });\n    if (clearHighlightedMessageTimeoutId.current) {\n      clearTimeout(clearHighlightedMessageTimeoutId.current);\n    }\n    clearHighlightedMessageTimeoutId.current = setTimeout(() => {\n      clearHighlightedMessageTimeoutId.current = null;\n      dispatch({\n        type: 'clearHighlightedMessage'\n      });\n    }, highlightDuration);\n  }, [addNotification, channel, loadMoreFinished, t, channelUnreadUiState]);\n  const deleteMessage = useCallback(async message => {\n    if (!message?.id) {\n      throw new Error('Cannot delete a message - missing message ID.');\n    }\n    let deletedMessage;\n    if (doDeleteMessageRequest) {\n      deletedMessage = await doDeleteMessageRequest(message);\n    } else {\n      const result = await client.deleteMessage(message.id);\n      deletedMessage = result.message;\n    }\n    return deletedMessage;\n  }, [client, doDeleteMessageRequest]);\n  const updateMessage = updatedMessage => {\n    // add the message to the local channel state\n    channel.state.addMessageSorted(updatedMessage, true);\n    dispatch({\n      channel,\n      parentId: state.thread && updatedMessage.parent_id,\n      type: 'copyMessagesFromChannel'\n    });\n  };\n  const doSendMessage = async (message, customMessageData, options) => {\n    const {\n      attachments,\n      id,\n      mentioned_users = [],\n      parent_id,\n      text\n    } = message;\n    // channel.sendMessage expects an array of user id strings\n    const mentions = isUserResponseArray(mentioned_users) ? mentioned_users.map(({\n      id\n    }) => id) : mentioned_users;\n    const messageData = {\n      attachments,\n      id,\n      mentioned_users: mentions,\n      parent_id,\n      quoted_message_id: parent_id === quotedMessage?.parent_id ? quotedMessage?.id : undefined,\n      text,\n      ...customMessageData\n    };\n    try {\n      let messageResponse;\n      if (doSendMessageRequest) {\n        messageResponse = await doSendMessageRequest(channel, messageData, options);\n      } else {\n        messageResponse = await channel.sendMessage(messageData, options);\n      }\n      let existingMessage;\n      for (let i = channel.state.messages.length - 1; i >= 0; i--) {\n        const msg = channel.state.messages[i];\n        if (msg.id && msg.id === messageData.id) {\n          existingMessage = msg;\n          break;\n        }\n      }\n      const responseTimestamp = new Date(messageResponse?.message?.updated_at || 0).getTime();\n      const existingMessageTimestamp = existingMessage?.updated_at?.getTime() || 0;\n      const responseIsTheNewest = responseTimestamp > existingMessageTimestamp;\n      // Replace the message payload after send is completed\n      // We need to check for the newest message payload, because on slow network, the response can arrive later than WS events message.new, message.updated.\n      // Always override existing message in status \"sending\"\n      if (messageResponse?.message && (responseIsTheNewest || existingMessage?.status === 'sending')) {\n        updateMessage({\n          ...messageResponse.message,\n          status: 'received'\n        });\n      }\n      if (quotedMessage && parent_id === quotedMessage?.parent_id) setQuotedMessage(undefined);\n    } catch (error) {\n      // error response isn't usable so needs to be stringified then parsed\n      const stringError = JSON.stringify(error);\n      const parsedError = stringError ? JSON.parse(stringError) : {};\n      // Handle the case where the message already exists\n      // (typically, when retrying to send a message).\n      // If the message already exists, we can assume it was sent successfully,\n      // so we update the message status to \"received\".\n      // Right now, the only way to check this error is by checking\n      // the combination of the error code and the error description,\n      // since there is no special error code for duplicate messages.\n      if (parsedError.code === 4 && error instanceof Error && error.message.includes('already exists')) {\n        updateMessage({\n          ...message,\n          status: 'received'\n        });\n      } else {\n        updateMessage({\n          ...message,\n          error: parsedError,\n          errorStatusCode: parsedError.status || undefined,\n          status: 'failed'\n        });\n        thread?.upsertReplyLocally({\n          // @ts-expect-error\n          message: {\n            ...message,\n            error: parsedError,\n            errorStatusCode: parsedError.status || undefined,\n            status: 'failed'\n          }\n        });\n      }\n    }\n  };\n  const sendMessage = async ({\n    attachments = [],\n    mentioned_users = [],\n    parent,\n    text = ''\n  }, customMessageData, options) => {\n    channel.state.filterErrorMessages();\n    const messagePreview = {\n      attachments,\n      created_at: new Date(),\n      html: text,\n      id: customMessageData?.id ?? `${client.userID}-${nanoid()}`,\n      mentioned_users,\n      parent_id: parent?.id,\n      reactions: [],\n      status: 'sending',\n      text,\n      type: 'regular',\n      user: client.user\n    };\n    thread?.upsertReplyLocally({\n      // @ts-expect-error\n      message: messagePreview\n    });\n    updateMessage(messagePreview);\n    await doSendMessage(messagePreview, customMessageData, options);\n  };\n  const retrySendMessage = async message => {\n    updateMessage({\n      ...message,\n      errorStatusCode: undefined,\n      status: 'sending'\n    });\n    if (message.attachments) {\n      // remove scraped attachments added during the message composition in MessageInput to prevent sync issues\n      message.attachments = message.attachments.filter(attachment => !attachment.og_scrape_url);\n    }\n    await doSendMessage(message);\n  };\n  const removeMessage = message => {\n    channel.state.removeMessage(message);\n    dispatch({\n      channel,\n      parentId: state.thread && message.parent_id,\n      type: 'copyMessagesFromChannel'\n    });\n  };\n  /** THREAD */\n  const openThread = (message, event) => {\n    event?.preventDefault();\n    setQuotedMessage(current => {\n      if (current?.parent_id !== message?.parent_id) {\n        return undefined;\n      } else {\n        return current;\n      }\n    });\n    dispatch({\n      channel,\n      message,\n      type: 'openThread'\n    });\n  };\n  const closeThread = event => {\n    event?.preventDefault();\n    dispatch({\n      type: 'closeThread'\n    });\n  };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const loadMoreThreadFinished = useCallback(debounce((threadHasMore, threadMessages) => {\n    dispatch({\n      threadHasMore,\n      threadMessages,\n      type: 'loadMoreThreadFinished'\n    });\n  }, 2000, {\n    leading: true,\n    trailing: true\n  }), []);\n  const loadMoreThread = async (limit = DEFAULT_THREAD_PAGE_SIZE) => {\n    // FIXME: should prevent loading more, if state.thread.reply_count === channel.state.threads[parentID].length\n    if (state.threadLoadingMore || !state.thread || !state.threadHasMore) return;\n    dispatch({\n      type: 'startLoadingThread'\n    });\n    const parentId = state.thread.id;\n    if (!parentId) {\n      return dispatch({\n        type: 'closeThread'\n      });\n    }\n    const oldMessages = channel.state.threads[parentId] || [];\n    const oldestMessageId = oldMessages[0]?.id;\n    try {\n      const queryResponse = await channel.getReplies(parentId, {\n        id_lt: oldestMessageId,\n        limit\n      });\n      const threadHasMoreMessages = hasMoreMessagesProbably(queryResponse.messages.length, limit);\n      const newThreadMessages = channel.state.threads[parentId] || [];\n      // next set loadingMore to false so we can start asking for more data\n      loadMoreThreadFinished(threadHasMoreMessages, newThreadMessages);\n    } catch (e) {\n      loadMoreThreadFinished(false, oldMessages);\n    }\n  };\n  const onMentionsHoverOrClick = useMentionsHandlers(onMentionsHover, onMentionsClick);\n  const editMessage = useEditMessageHandler(doUpdateMessageRequest);\n  const {\n    typing,\n    ...restState\n  } = state;\n  const channelStateContextValue = useCreateChannelStateContext({\n    ...restState,\n    acceptedFiles,\n    channel,\n    channelCapabilitiesArray,\n    channelConfig,\n    channelUnreadUiState,\n    debounceURLEnrichmentMs: enrichURLForPreviewConfig?.debounceURLEnrichmentMs,\n    dragAndDropWindow,\n    enrichURLForPreview: props.enrichURLForPreview,\n    findURLFn: enrichURLForPreviewConfig?.findURLFn,\n    giphyVersion: props.giphyVersion || 'fixed_height',\n    imageAttachmentSizeHandler: props.imageAttachmentSizeHandler || getImageAttachmentConfiguration,\n    maxNumberOfFiles,\n    multipleUploads,\n    mutes,\n    notifications,\n    onLinkPreviewDismissed: enrichURLForPreviewConfig?.onLinkPreviewDismissed,\n    quotedMessage,\n    shouldGenerateVideoThumbnail: props.shouldGenerateVideoThumbnail || true,\n    videoAttachmentSizeHandler: props.videoAttachmentSizeHandler || getVideoAttachmentConfiguration,\n    watcher_count: state.watcherCount\n  });\n  const channelActionContextValue = useMemo(() => ({\n    addNotification,\n    closeThread,\n    deleteMessage,\n    dispatch,\n    editMessage,\n    jumpToFirstUnreadMessage,\n    jumpToLatestMessage,\n    jumpToMessage,\n    loadMore,\n    loadMoreNewer,\n    loadMoreThread,\n    markRead,\n    onMentionsClick: onMentionsHoverOrClick,\n    onMentionsHover: onMentionsHoverOrClick,\n    openThread,\n    removeMessage,\n    retrySendMessage,\n    sendMessage,\n    setChannelUnreadUiState,\n    setQuotedMessage,\n    skipMessageDataMemoization,\n    updateMessage\n  }),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [channel.cid, deleteMessage, enrichURLForPreviewConfig?.findURLFn, enrichURLForPreviewConfig?.onLinkPreviewDismissed, loadMore, loadMoreNewer, markRead, quotedMessage, jumpToFirstUnreadMessage, jumpToMessage, jumpToLatestMessage, setChannelUnreadUiState]);\n  // @ts-expect-error\n  const componentContextValue = useMemo(() => ({\n    Attachment: props.Attachment,\n    AttachmentPreviewList: props.AttachmentPreviewList,\n    AttachmentSelector: props.AttachmentSelector,\n    AttachmentSelectorInitiationButtonContents: props.AttachmentSelectorInitiationButtonContents,\n    AudioRecorder: props.AudioRecorder,\n    AutocompleteSuggestionItem: props.AutocompleteSuggestionItem,\n    AutocompleteSuggestionList: props.AutocompleteSuggestionList,\n    Avatar: props.Avatar,\n    BaseImage: props.BaseImage,\n    CooldownTimer: props.CooldownTimer,\n    CustomMessageActionsList: props.CustomMessageActionsList,\n    DateSeparator: props.DateSeparator,\n    EditMessageInput: props.EditMessageInput,\n    EmojiPicker: props.EmojiPicker,\n    emojiSearchIndex: props.emojiSearchIndex,\n    EmptyStateIndicator: props.EmptyStateIndicator,\n    FileUploadIcon: props.FileUploadIcon,\n    GiphyPreviewMessage: props.GiphyPreviewMessage,\n    HeaderComponent: props.HeaderComponent,\n    Input: props.Input,\n    LinkPreviewList: props.LinkPreviewList,\n    LoadingIndicator: props.LoadingIndicator,\n    Message: props.Message,\n    MessageActions: props.MessageActions,\n    MessageBouncePrompt: props.MessageBouncePrompt,\n    MessageDeleted: props.MessageDeleted,\n    MessageListNotifications: props.MessageListNotifications,\n    MessageNotification: props.MessageNotification,\n    MessageOptions: props.MessageOptions,\n    MessageRepliesCountButton: props.MessageRepliesCountButton,\n    MessageStatus: props.MessageStatus,\n    MessageSystem: props.MessageSystem,\n    MessageTimestamp: props.MessageTimestamp,\n    ModalGallery: props.ModalGallery,\n    PinIndicator: props.PinIndicator,\n    PollActions: props.PollActions,\n    PollContent: props.PollContent,\n    PollCreationDialog: props.PollCreationDialog,\n    PollHeader: props.PollHeader,\n    PollOptionSelector: props.PollOptionSelector,\n    QuotedMessage: props.QuotedMessage,\n    QuotedMessagePreview: props.QuotedMessagePreview,\n    QuotedPoll: props.QuotedPoll,\n    reactionOptions: props.reactionOptions,\n    ReactionSelector: props.ReactionSelector,\n    ReactionsList: props.ReactionsList,\n    SendButton: props.SendButton,\n    StartRecordingAudioButton: props.StartRecordingAudioButton,\n    ThreadHead: props.ThreadHead,\n    ThreadHeader: props.ThreadHeader,\n    ThreadStart: props.ThreadStart,\n    Timestamp: props.Timestamp,\n    TriggerProvider: props.TriggerProvider,\n    TypingIndicator: props.TypingIndicator,\n    UnreadMessagesNotification: props.UnreadMessagesNotification,\n    UnreadMessagesSeparator: props.UnreadMessagesSeparator,\n    VirtualMessage: props.VirtualMessage\n  }), [props.Attachment, props.AttachmentPreviewList, props.AttachmentSelector, props.AttachmentSelectorInitiationButtonContents, props.AudioRecorder, props.AutocompleteSuggestionItem, props.AutocompleteSuggestionList, props.Avatar, props.BaseImage, props.CooldownTimer, props.CustomMessageActionsList, props.DateSeparator, props.EditMessageInput, props.EmojiPicker, props.EmptyStateIndicator, props.FileUploadIcon, props.GiphyPreviewMessage, props.HeaderComponent, props.Input, props.LinkPreviewList, props.LoadingIndicator, props.Message, props.MessageActions, props.MessageBouncePrompt, props.MessageDeleted, props.MessageListNotifications, props.MessageNotification, props.MessageOptions, props.MessageRepliesCountButton, props.MessageStatus, props.MessageSystem, props.MessageTimestamp, props.ModalGallery, props.PinIndicator, props.PollActions, props.PollContent, props.PollCreationDialog, props.PollHeader, props.PollOptionSelector, props.QuotedMessage, props.QuotedMessagePreview, props.QuotedPoll, props.ReactionSelector, props.ReactionsList, props.SendButton, props.StartRecordingAudioButton, props.ThreadHead, props.ThreadHeader, props.ThreadStart, props.Timestamp, props.TriggerProvider, props.TypingIndicator, props.UnreadMessagesNotification, props.UnreadMessagesSeparator, props.VirtualMessage, props.emojiSearchIndex, props.reactionOptions]);\n  const typingContextValue = useCreateTypingContext({\n    typing\n  });\n  if (state.error) {\n    return React.createElement(ChannelContainer, null, React.createElement(LoadingErrorIndicator, {\n      error: state.error\n    }));\n  }\n  if (state.loading) {\n    return React.createElement(ChannelContainer, null, React.createElement(LoadingIndicator, null));\n  }\n  if (!channel.watch) {\n    return React.createElement(ChannelContainer, null, React.createElement(\"div\", null, t('Channel Missing')));\n  }\n  return React.createElement(ChannelContainer, {\n    className: windowsEmojiClass\n  }, React.createElement(ChannelStateProvider, {\n    value: channelStateContextValue\n  }, React.createElement(ChannelActionProvider, {\n    value: channelActionContextValue\n  }, React.createElement(WithComponents, {\n    overrides: componentContextValue\n  }, React.createElement(TypingProvider, {\n    value: typingContextValue\n  }, React.createElement(\"div\", {\n    className: `${chatContainerClass}`\n  }, dragAndDropWindow && React.createElement(DropzoneProvider, {\n    ...optionalMessageInputProps\n  }, children), !dragAndDropWindow && React.createElement(React.Fragment, null, children)))))));\n};\n/**\n * A wrapper component that provides channel data and renders children.\n * The Channel component provides the following contexts:\n * - [ChannelStateContext](https://getstream.io/chat/docs/sdk/react/contexts/channel_state_context/)\n * - [ChannelActionContext](https://getstream.io/chat/docs/sdk/react/contexts/channel_action_context/)\n * - [ComponentContext](https://getstream.io/chat/docs/sdk/react/contexts/component_context/)\n * - [TypingContext](https://getstream.io/chat/docs/sdk/react/contexts/typing_context/)\n */\nexport const Channel = React.memo(UnMemoizedChannel);","map":{"version":3,"names":["React","useCallback","useEffect","useLayoutEffect","useMemo","useReducer","useRef","useState","debounce","defaultsDeep","throttle","nanoid","clsx","channelReducer","initialState","useCreateChannelStateContext","useCreateTypingContext","useEditMessageHandler","useIsMounted","useMentionsHandlers","LoadingErrorIndicator","DefaultLoadingErrorIndicator","LoadingChannel","DefaultLoadingIndicator","DropzoneProvider","ChannelActionProvider","ChannelStateProvider","TypingProvider","useChatContext","useTranslationContext","WithComponents","DEFAULT_HIGHLIGHT_DURATION","DEFAULT_INITIAL_CHANNEL_PAGE_SIZE","DEFAULT_JUMP_TO_PAGE_SIZE","DEFAULT_NEXT_CHANNEL_PAGE_SIZE","DEFAULT_THREAD_PAGE_SIZE","hasMoreMessagesProbably","getChatContainerClass","useChannelContainerClasses","useImageFlagEmojisOnWindowsClass","findInMsgSetByDate","findInMsgSetById","makeAddNotifications","getChannel","getImageAttachmentConfiguration","getVideoAttachmentConfiguration","useThreadContext","CHANNEL_CONTAINER_ID","isUserResponseArray","output","id","ChannelContainer","children","className","additionalClassName","props","customClasses","theme","channelClass","chatClass","createElement","UnMemoizedChannel","channel","propsChannel","EmptyPlaceholder","LoadingIndicator","contextChannel","channelsQueryState","queryInProgress","error","cid","ChannelInner","key","acceptedFiles","activeUnreadHandler","channelQueryOptions","propChannelQueryOptions","doDeleteMessageRequest","doMarkReadRequest","doSendMessageRequest","doUpdateMessageRequest","dragAndDropWindow","enrichURLForPreviewConfig","initializeOnMount","markReadOnMount","maxNumberOfFiles","multipleUploads","onMentionsClick","onMentionsHover","optionalMessageInputProps","skipMessageDataMemoization","messages","limit","client","latestMessageDatesByChannels","mutes","t","chatContainerClass","chatContainer","windowsEmojiClass","thread","channelConfig","setChannelConfig","getConfig","notifications","setNotifications","quotedMessage","setQuotedMessage","channelUnreadUiState","_setChannelUnreadUiState","notificationTimeouts","state","dispatch","hasMore","messagePagination","hasPrev","loading","initialized","isMounted","originalTitle","lastRead","online","channelCapabilitiesArray","data","own_capabilities","throttledCopyStateFromChannel","type","leading","trailing","setChannelUnreadUiState","markRead","options","updateChannelUiUnreadState","disconnected","read_events","current","Date","undefined","markReadResponse","last_read","last_read_message_id","event","unread_messages","document","title","e","console","handleEvent","message","mainChannelUpdated","parent_id","show_in_channel","hidden","muteStatus","muted","unread","countUnread","user","userID","created_at","messageDate","getTime","oldestID","query","id_lt","watchers","prev","last_read_at","first_unread_message_id","errored","done","members","member","userId","user_id","push","config","read","ownReadState","on","notificationTimeoutsRef","off","forEach","clearTimeout","find","m","addNotification","loadMoreFinished","loadMore","window","navigator","onLine","oldestMessage","loadingMore","loadingMoreNewer","status","perPage","queryResponse","warn","length","loadMoreNewer","hasNext","newestMessage","newestId","id_gt","hasMoreNewer","clearHighlightedMessageTimeoutId","jumpToMessage","messageId","messageLimit","highlightDuration","loadMessageIntoState","highlightedMessageId","setTimeout","jumpToLatestMessage","jumpToFirstUnreadMessage","queryMessageLimit","lastReadMessageId","firstUnreadMessageId","isInCurrentMessageSet","result","index","target","lastReadTimestamp","lastReadMessageIndex","lastReadMessage","created_at_around","toISOString","firstMessageWithCreationDate","msg","firstMessageTimestamp","targetId","indexOfTarget","findIndex","deleteMessage","Error","deletedMessage","updateMessage","updatedMessage","addMessageSorted","parentId","doSendMessage","customMessageData","attachments","mentioned_users","text","mentions","map","messageData","quoted_message_id","messageResponse","sendMessage","existingMessage","i","responseTimestamp","updated_at","existingMessageTimestamp","responseIsTheNewest","stringError","JSON","stringify","parsedError","parse","code","includes","errorStatusCode","upsertReplyLocally","parent","filterErrorMessages","messagePreview","html","reactions","retrySendMessage","filter","attachment","og_scrape_url","removeMessage","openThread","preventDefault","closeThread","loadMoreThreadFinished","threadHasMore","threadMessages","loadMoreThread","threadLoadingMore","oldMessages","threads","oldestMessageId","getReplies","threadHasMoreMessages","newThreadMessages","onMentionsHoverOrClick","editMessage","typing","restState","channelStateContextValue","debounceURLEnrichmentMs","enrichURLForPreview","findURLFn","giphyVersion","imageAttachmentSizeHandler","onLinkPreviewDismissed","shouldGenerateVideoThumbnail","videoAttachmentSizeHandler","watcher_count","watcherCount","channelActionContextValue","componentContextValue","Attachment","AttachmentPreviewList","AttachmentSelector","AttachmentSelectorInitiationButtonContents","AudioRecorder","AutocompleteSuggestionItem","AutocompleteSuggestionList","Avatar","BaseImage","CooldownTimer","CustomMessageActionsList","DateSeparator","EditMessageInput","EmojiPicker","emojiSearchIndex","EmptyStateIndicator","FileUploadIcon","GiphyPreviewMessage","HeaderComponent","Input","LinkPreviewList","Message","MessageActions","MessageBouncePrompt","MessageDeleted","MessageListNotifications","MessageNotification","MessageOptions","MessageRepliesCountButton","MessageStatus","MessageSystem","MessageTimestamp","ModalGallery","PinIndicator","PollActions","PollContent","PollCreationDialog","PollHeader","PollOptionSelector","QuotedMessage","QuotedMessagePreview","QuotedPoll","reactionOptions","ReactionSelector","ReactionsList","SendButton","StartRecordingAudioButton","ThreadHead","ThreadHeader","ThreadStart","Timestamp","TriggerProvider","TypingIndicator","UnreadMessagesNotification","UnreadMessagesSeparator","VirtualMessage","typingContextValue","watch","value","overrides","Fragment","Channel","memo"],"sources":["C:/Users/abdel/OneDrive/Desktop/Medical-plager/client/node_modules/stream-chat-react/dist/components/Channel/Channel.js"],"sourcesContent":["import React, { useCallback, useEffect, useLayoutEffect, useMemo, useReducer, useRef, useState, } from 'react';\nimport debounce from 'lodash.debounce';\nimport defaultsDeep from 'lodash.defaultsdeep';\nimport throttle from 'lodash.throttle';\nimport { nanoid } from 'nanoid';\nimport clsx from 'clsx';\nimport { channelReducer, initialState } from './channelState';\nimport { useCreateChannelStateContext } from './hooks/useCreateChannelStateContext';\nimport { useCreateTypingContext } from './hooks/useCreateTypingContext';\nimport { useEditMessageHandler } from './hooks/useEditMessageHandler';\nimport { useIsMounted } from './hooks/useIsMounted';\nimport { useMentionsHandlers } from './hooks/useMentionsHandlers';\nimport { LoadingErrorIndicator as DefaultLoadingErrorIndicator, } from '../Loading';\nimport { LoadingChannel as DefaultLoadingIndicator } from './LoadingChannel';\nimport { DropzoneProvider } from '../MessageInput/DropzoneProvider';\nimport { ChannelActionProvider, ChannelStateProvider, TypingProvider, useChatContext, useTranslationContext, WithComponents, } from '../../context';\nimport { DEFAULT_HIGHLIGHT_DURATION, DEFAULT_INITIAL_CHANNEL_PAGE_SIZE, DEFAULT_JUMP_TO_PAGE_SIZE, DEFAULT_NEXT_CHANNEL_PAGE_SIZE, DEFAULT_THREAD_PAGE_SIZE, } from '../../constants/limits';\nimport { hasMoreMessagesProbably } from '../MessageList';\nimport { getChatContainerClass, useChannelContainerClasses, useImageFlagEmojisOnWindowsClass, } from './hooks/useChannelContainerClasses';\nimport { findInMsgSetByDate, findInMsgSetById, makeAddNotifications } from './utils';\nimport { getChannel } from '../../utils';\nimport { getImageAttachmentConfiguration, getVideoAttachmentConfiguration, } from '../Attachment/attachment-sizing';\nimport { useThreadContext } from '../Threads';\nimport { CHANNEL_CONTAINER_ID } from './constants';\nconst isUserResponseArray = (output) => output[0]?.id != null;\nconst ChannelContainer = ({ children, className: additionalClassName, ...props }) => {\n    const { customClasses, theme } = useChatContext('Channel');\n    const { channelClass, chatClass } = useChannelContainerClasses({\n        customClasses,\n    });\n    const className = clsx(chatClass, theme, channelClass, additionalClassName);\n    return (React.createElement(\"div\", { id: CHANNEL_CONTAINER_ID, ...props, className: className }, children));\n};\nconst UnMemoizedChannel = (props) => {\n    const { channel: propsChannel, EmptyPlaceholder = null, LoadingErrorIndicator, LoadingIndicator = DefaultLoadingIndicator, } = props;\n    const { channel: contextChannel, channelsQueryState } = useChatContext('Channel');\n    const channel = propsChannel || contextChannel;\n    if (channelsQueryState.queryInProgress === 'reload' && LoadingIndicator) {\n        return (React.createElement(ChannelContainer, null,\n            React.createElement(LoadingIndicator, null)));\n    }\n    if (channelsQueryState.error && LoadingErrorIndicator) {\n        return (React.createElement(ChannelContainer, null,\n            React.createElement(LoadingErrorIndicator, { error: channelsQueryState.error })));\n    }\n    if (!channel?.cid) {\n        return React.createElement(ChannelContainer, null, EmptyPlaceholder);\n    }\n    return React.createElement(ChannelInner, { ...props, channel: channel, key: channel.cid });\n};\nconst ChannelInner = (props) => {\n    const { acceptedFiles, activeUnreadHandler, channel, channelQueryOptions: propChannelQueryOptions, children, doDeleteMessageRequest, doMarkReadRequest, doSendMessageRequest, doUpdateMessageRequest, dragAndDropWindow = false, enrichURLForPreviewConfig, initializeOnMount = true, LoadingErrorIndicator = DefaultLoadingErrorIndicator, LoadingIndicator = DefaultLoadingIndicator, markReadOnMount = true, maxNumberOfFiles, multipleUploads = true, onMentionsClick, onMentionsHover, optionalMessageInputProps = {}, skipMessageDataMemoization, } = props;\n    const channelQueryOptions = useMemo(() => defaultsDeep(propChannelQueryOptions, {\n        messages: { limit: DEFAULT_INITIAL_CHANNEL_PAGE_SIZE },\n    }), [propChannelQueryOptions]);\n    const { client, customClasses, latestMessageDatesByChannels, mutes, } = useChatContext('Channel');\n    const { t } = useTranslationContext('Channel');\n    const chatContainerClass = getChatContainerClass(customClasses?.chatContainer);\n    const windowsEmojiClass = useImageFlagEmojisOnWindowsClass();\n    const thread = useThreadContext();\n    const [channelConfig, setChannelConfig] = useState(channel.getConfig());\n    const [notifications, setNotifications] = useState([]);\n    const [quotedMessage, setQuotedMessage] = useState();\n    const [channelUnreadUiState, _setChannelUnreadUiState] = useState();\n    const notificationTimeouts = useRef([]);\n    const [state, dispatch] = useReducer(channelReducer, \n    // channel.initialized === false if client.channel().query() was not called, e.g. ChannelList is not used\n    // => Channel will call channel.watch() in useLayoutEffect => state.loading is used to signal the watch() call state\n    {\n        ...initialState,\n        hasMore: channel.state.messagePagination.hasPrev,\n        loading: !channel.initialized,\n    });\n    const isMounted = useIsMounted();\n    const originalTitle = useRef('');\n    const lastRead = useRef();\n    const online = useRef(true);\n    const channelCapabilitiesArray = channel.data?.own_capabilities;\n    const throttledCopyStateFromChannel = throttle(() => dispatch({ channel, type: 'copyStateFromChannelOnEvent' }), 500, {\n        leading: true,\n        trailing: true,\n    });\n    const setChannelUnreadUiState = useMemo(() => throttle(_setChannelUnreadUiState, 200, {\n        leading: true,\n        trailing: false,\n    }), []);\n    const markRead = useMemo(() => throttle(async (options) => {\n        const { updateChannelUiUnreadState = true } = options ?? {};\n        if (channel.disconnected || !channelConfig?.read_events) {\n            return;\n        }\n        lastRead.current = new Date();\n        try {\n            if (doMarkReadRequest) {\n                doMarkReadRequest(channel, updateChannelUiUnreadState ? setChannelUnreadUiState : undefined);\n            }\n            else {\n                const markReadResponse = await channel.markRead();\n                if (updateChannelUiUnreadState && markReadResponse) {\n                    _setChannelUnreadUiState({\n                        last_read: lastRead.current,\n                        last_read_message_id: markReadResponse.event.last_read_message_id,\n                        unread_messages: 0,\n                    });\n                }\n            }\n            if (activeUnreadHandler) {\n                activeUnreadHandler(0, originalTitle.current);\n            }\n            else if (originalTitle.current) {\n                document.title = originalTitle.current;\n            }\n        }\n        catch (e) {\n            console.error(t('Failed to mark channel as read'));\n        }\n    }, 500, { leading: true, trailing: false }), [activeUnreadHandler, channel, channelConfig, doMarkReadRequest, setChannelUnreadUiState, t]);\n    const handleEvent = async (event) => {\n        if (event.message) {\n            dispatch({\n                channel,\n                message: event.message,\n                type: 'updateThreadOnEvent',\n            });\n        }\n        if (event.type === 'user.watching.start' || event.type === 'user.watching.stop')\n            return;\n        if (event.type === 'typing.start' || event.type === 'typing.stop') {\n            return dispatch({ channel, type: 'setTyping' });\n        }\n        if (event.type === 'connection.changed' && typeof event.online === 'boolean') {\n            online.current = event.online;\n        }\n        if (event.type === 'message.new') {\n            const mainChannelUpdated = !event.message?.parent_id || event.message?.show_in_channel;\n            if (mainChannelUpdated) {\n                if (document.hidden && channelConfig?.read_events && !channel.muteStatus().muted) {\n                    const unread = channel.countUnread(lastRead.current);\n                    if (activeUnreadHandler) {\n                        activeUnreadHandler(unread, originalTitle.current);\n                    }\n                    else {\n                        document.title = `(${unread}) ${originalTitle.current}`;\n                    }\n                }\n            }\n            if (event.message?.user?.id === client.userID &&\n                event?.message?.created_at &&\n                event?.message?.cid) {\n                const messageDate = new Date(event.message.created_at);\n                const cid = event.message.cid;\n                if (!latestMessageDatesByChannels[cid] ||\n                    latestMessageDatesByChannels[cid].getTime() < messageDate.getTime()) {\n                    latestMessageDatesByChannels[cid] = messageDate;\n                }\n            }\n        }\n        if (event.type === 'user.deleted') {\n            const oldestID = channel.state?.messages?.[0]?.id;\n            /**\n             * As the channel state is not normalized we re-fetch the channel data. Thus, we avoid having to search for user references in the channel state.\n             */\n            // FIXME: we should use channelQueryOptions if they are available\n            await channel.query({\n                messages: { id_lt: oldestID, limit: DEFAULT_NEXT_CHANNEL_PAGE_SIZE },\n                watchers: { limit: DEFAULT_NEXT_CHANNEL_PAGE_SIZE },\n            });\n        }\n        if (event.type === 'notification.mark_unread')\n            _setChannelUnreadUiState((prev) => {\n                if (!(event.last_read_at && event.user))\n                    return prev;\n                return {\n                    first_unread_message_id: event.first_unread_message_id,\n                    last_read: new Date(event.last_read_at),\n                    last_read_message_id: event.last_read_message_id,\n                    unread_messages: event.unread_messages ?? 0,\n                };\n            });\n        if (event.type === 'channel.truncated' && event.cid === channel.cid) {\n            _setChannelUnreadUiState(undefined);\n        }\n        throttledCopyStateFromChannel();\n    };\n    // useLayoutEffect here to prevent spinner. Use Suspense when it is available in stable release\n    useLayoutEffect(() => {\n        let errored = false;\n        let done = false;\n        (async () => {\n            if (!channel.initialized && initializeOnMount) {\n                try {\n                    // if active channel has been set without id, we will create a temporary channel id from its member IDs\n                    // to keep track of the /query request in progress. This is the same approach of generating temporary id\n                    // that the JS client uses to keep track of channel in client.activeChannels\n                    const members = [];\n                    if (!channel.id && channel.data?.members) {\n                        for (const member of channel.data.members) {\n                            let userId;\n                            if (typeof member === 'string') {\n                                userId = member;\n                            }\n                            else if (typeof member === 'object') {\n                                const { user, user_id } = member;\n                                userId = user_id || user?.id;\n                            }\n                            if (userId) {\n                                members.push(userId);\n                            }\n                        }\n                    }\n                    await getChannel({ channel, client, members, options: channelQueryOptions });\n                    const config = channel.getConfig();\n                    setChannelConfig(config);\n                }\n                catch (e) {\n                    dispatch({ error: e, type: 'setError' });\n                    errored = true;\n                }\n            }\n            done = true;\n            originalTitle.current = document.title;\n            if (!errored) {\n                dispatch({\n                    channel,\n                    hasMore: channel.state.messagePagination.hasPrev,\n                    type: 'initStateFromChannel',\n                });\n                if (client.user?.id && channel.state.read[client.user.id]) {\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    const { user, ...ownReadState } = channel.state.read[client.user.id];\n                    _setChannelUnreadUiState(ownReadState);\n                }\n                /**\n                 * TODO: maybe pass last_read to the countUnread method to get proper value\n                 * combined with channel.countUnread adjustment (_countMessageAsUnread)\n                 * to allow counting own messages too\n                 *\n                 * const lastRead = channel.state.read[client.userID as string].last_read;\n                 */\n                if (channel.countUnread() > 0 && markReadOnMount)\n                    markRead({ updateChannelUiUnreadState: false });\n                // The more complex sync logic is done in Chat\n                client.on('connection.changed', handleEvent);\n                client.on('connection.recovered', handleEvent);\n                client.on('user.updated', handleEvent);\n                client.on('user.deleted', handleEvent);\n                channel.on(handleEvent);\n            }\n        })();\n        const notificationTimeoutsRef = notificationTimeouts.current;\n        return () => {\n            if (errored || !done)\n                return;\n            channel?.off(handleEvent);\n            client.off('connection.changed', handleEvent);\n            client.off('connection.recovered', handleEvent);\n            client.off('user.deleted', handleEvent);\n            notificationTimeoutsRef.forEach(clearTimeout);\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        channel.cid,\n        channelQueryOptions,\n        doMarkReadRequest,\n        channelConfig?.read_events,\n        initializeOnMount,\n    ]);\n    useEffect(() => {\n        if (!state.thread)\n            return;\n        const message = state.messages?.find((m) => m.id === state.thread?.id);\n        if (message)\n            dispatch({ message, type: 'setThread' });\n    }, [state.messages, state.thread]);\n    /** MESSAGE */\n    // Adds a temporary notification to message list, will be removed after 5 seconds\n    const addNotification = useMemo(() => makeAddNotifications(setNotifications, notificationTimeouts.current), []);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const loadMoreFinished = useCallback(debounce((hasMore, messages) => {\n        if (!isMounted.current)\n            return;\n        dispatch({ hasMore, messages, type: 'loadMoreFinished' });\n    }, 2000, { leading: true, trailing: true }), []);\n    const loadMore = async (limit = DEFAULT_NEXT_CHANNEL_PAGE_SIZE) => {\n        if (!online.current || !window.navigator.onLine || !channel.state.messagePagination.hasPrev)\n            return 0;\n        // prevent duplicate loading events...\n        const oldestMessage = state?.messages?.[0];\n        if (state.loadingMore || state.loadingMoreNewer || oldestMessage?.status !== 'received') {\n            return 0;\n        }\n        dispatch({ loadingMore: true, type: 'setLoadingMore' });\n        const oldestID = oldestMessage?.id;\n        const perPage = limit;\n        let queryResponse;\n        try {\n            queryResponse = await channel.query({\n                messages: { id_lt: oldestID, limit: perPage },\n                watchers: { limit: perPage },\n            });\n        }\n        catch (e) {\n            console.warn('message pagination request failed with error', e);\n            dispatch({ loadingMore: false, type: 'setLoadingMore' });\n            return 0;\n        }\n        loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n        return queryResponse.messages.length;\n    };\n    const loadMoreNewer = async (limit = DEFAULT_NEXT_CHANNEL_PAGE_SIZE) => {\n        if (!online.current || !window.navigator.onLine || !channel.state.messagePagination.hasNext)\n            return 0;\n        const newestMessage = state?.messages?.[state?.messages?.length - 1];\n        if (state.loadingMore || state.loadingMoreNewer)\n            return 0;\n        dispatch({ loadingMoreNewer: true, type: 'setLoadingMoreNewer' });\n        const newestId = newestMessage?.id;\n        const perPage = limit;\n        let queryResponse;\n        try {\n            queryResponse = await channel.query({\n                messages: { id_gt: newestId, limit: perPage },\n                watchers: { limit: perPage },\n            });\n        }\n        catch (e) {\n            console.warn('message pagination request failed with error', e);\n            dispatch({ loadingMoreNewer: false, type: 'setLoadingMoreNewer' });\n            return 0;\n        }\n        dispatch({\n            hasMoreNewer: channel.state.messagePagination.hasNext,\n            messages: channel.state.messages,\n            type: 'loadMoreNewerFinished',\n        });\n        return queryResponse.messages.length;\n    };\n    const clearHighlightedMessageTimeoutId = useRef(null);\n    const jumpToMessage = useCallback(async (messageId, messageLimit = DEFAULT_JUMP_TO_PAGE_SIZE, highlightDuration = DEFAULT_HIGHLIGHT_DURATION) => {\n        dispatch({ loadingMore: true, type: 'setLoadingMore' });\n        await channel.state.loadMessageIntoState(messageId, undefined, messageLimit);\n        loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n        dispatch({\n            hasMoreNewer: channel.state.messagePagination.hasNext,\n            highlightedMessageId: messageId,\n            type: 'jumpToMessageFinished',\n        });\n        if (clearHighlightedMessageTimeoutId.current) {\n            clearTimeout(clearHighlightedMessageTimeoutId.current);\n        }\n        clearHighlightedMessageTimeoutId.current = setTimeout(() => {\n            clearHighlightedMessageTimeoutId.current = null;\n            dispatch({ type: 'clearHighlightedMessage' });\n        }, highlightDuration);\n    }, [channel, loadMoreFinished]);\n    const jumpToLatestMessage = useCallback(async () => {\n        await channel.state.loadMessageIntoState('latest');\n        loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n        dispatch({\n            type: 'jumpToLatestMessage',\n        });\n    }, [channel, loadMoreFinished]);\n    const jumpToFirstUnreadMessage = useCallback(async (queryMessageLimit = DEFAULT_JUMP_TO_PAGE_SIZE, highlightDuration = DEFAULT_HIGHLIGHT_DURATION) => {\n        if (!channelUnreadUiState?.unread_messages)\n            return;\n        let lastReadMessageId = channelUnreadUiState?.last_read_message_id;\n        let firstUnreadMessageId = channelUnreadUiState?.first_unread_message_id;\n        let isInCurrentMessageSet = false;\n        if (firstUnreadMessageId) {\n            const result = findInMsgSetById(firstUnreadMessageId, channel.state.messages);\n            isInCurrentMessageSet = result.index !== -1;\n        }\n        else if (lastReadMessageId) {\n            const result = findInMsgSetById(lastReadMessageId, channel.state.messages);\n            isInCurrentMessageSet = !!result.target;\n            firstUnreadMessageId =\n                result.index > -1 ? channel.state.messages[result.index + 1]?.id : undefined;\n        }\n        else {\n            const lastReadTimestamp = channelUnreadUiState.last_read.getTime();\n            const { index: lastReadMessageIndex, target: lastReadMessage } = findInMsgSetByDate(channelUnreadUiState.last_read, channel.state.messages, true);\n            if (lastReadMessage) {\n                firstUnreadMessageId = channel.state.messages[lastReadMessageIndex + 1]?.id;\n                isInCurrentMessageSet = !!firstUnreadMessageId;\n                lastReadMessageId = lastReadMessage.id;\n            }\n            else {\n                dispatch({ loadingMore: true, type: 'setLoadingMore' });\n                let messages;\n                try {\n                    messages = (await channel.query({\n                        messages: {\n                            created_at_around: channelUnreadUiState.last_read.toISOString(),\n                            limit: queryMessageLimit,\n                        },\n                    }, 'new')).messages;\n                }\n                catch (e) {\n                    addNotification(t('Failed to jump to the first unread message'), 'error');\n                    loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n                    return;\n                }\n                const firstMessageWithCreationDate = messages.find((msg) => msg.created_at);\n                if (!firstMessageWithCreationDate) {\n                    addNotification(t('Failed to jump to the first unread message'), 'error');\n                    loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n                    return;\n                }\n                const firstMessageTimestamp = new Date(firstMessageWithCreationDate.created_at).getTime();\n                if (lastReadTimestamp < firstMessageTimestamp) {\n                    // whole channel is unread\n                    firstUnreadMessageId = firstMessageWithCreationDate.id;\n                }\n                else {\n                    const result = findInMsgSetByDate(channelUnreadUiState.last_read, messages);\n                    lastReadMessageId = result.target?.id;\n                }\n                loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n            }\n        }\n        if (!firstUnreadMessageId && !lastReadMessageId) {\n            addNotification(t('Failed to jump to the first unread message'), 'error');\n            return;\n        }\n        if (!isInCurrentMessageSet) {\n            dispatch({ loadingMore: true, type: 'setLoadingMore' });\n            try {\n                const targetId = (firstUnreadMessageId ?? lastReadMessageId);\n                await channel.state.loadMessageIntoState(targetId, undefined, queryMessageLimit);\n                /**\n                 * if the index of the last read message on the page is beyond the half of the page,\n                 * we have arrived to the oldest page of the channel\n                 */\n                const indexOfTarget = channel.state.messages.findIndex((message) => message.id === targetId);\n                loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n                firstUnreadMessageId =\n                    firstUnreadMessageId ?? channel.state.messages[indexOfTarget + 1]?.id;\n            }\n            catch (e) {\n                addNotification(t('Failed to jump to the first unread message'), 'error');\n                loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n                return;\n            }\n        }\n        if (!firstUnreadMessageId) {\n            addNotification(t('Failed to jump to the first unread message'), 'error');\n            return;\n        }\n        if (!channelUnreadUiState.first_unread_message_id)\n            _setChannelUnreadUiState({\n                ...channelUnreadUiState,\n                first_unread_message_id: firstUnreadMessageId,\n                last_read_message_id: lastReadMessageId,\n            });\n        dispatch({\n            hasMoreNewer: channel.state.messagePagination.hasNext,\n            highlightedMessageId: firstUnreadMessageId,\n            type: 'jumpToMessageFinished',\n        });\n        if (clearHighlightedMessageTimeoutId.current) {\n            clearTimeout(clearHighlightedMessageTimeoutId.current);\n        }\n        clearHighlightedMessageTimeoutId.current = setTimeout(() => {\n            clearHighlightedMessageTimeoutId.current = null;\n            dispatch({ type: 'clearHighlightedMessage' });\n        }, highlightDuration);\n    }, [addNotification, channel, loadMoreFinished, t, channelUnreadUiState]);\n    const deleteMessage = useCallback(async (message) => {\n        if (!message?.id) {\n            throw new Error('Cannot delete a message - missing message ID.');\n        }\n        let deletedMessage;\n        if (doDeleteMessageRequest) {\n            deletedMessage = await doDeleteMessageRequest(message);\n        }\n        else {\n            const result = await client.deleteMessage(message.id);\n            deletedMessage = result.message;\n        }\n        return deletedMessage;\n    }, [client, doDeleteMessageRequest]);\n    const updateMessage = (updatedMessage) => {\n        // add the message to the local channel state\n        channel.state.addMessageSorted(updatedMessage, true);\n        dispatch({\n            channel,\n            parentId: state.thread && updatedMessage.parent_id,\n            type: 'copyMessagesFromChannel',\n        });\n    };\n    const doSendMessage = async (message, customMessageData, options) => {\n        const { attachments, id, mentioned_users = [], parent_id, text } = message;\n        // channel.sendMessage expects an array of user id strings\n        const mentions = isUserResponseArray(mentioned_users)\n            ? mentioned_users.map(({ id }) => id)\n            : mentioned_users;\n        const messageData = {\n            attachments,\n            id,\n            mentioned_users: mentions,\n            parent_id,\n            quoted_message_id: parent_id === quotedMessage?.parent_id ? quotedMessage?.id : undefined,\n            text,\n            ...customMessageData,\n        };\n        try {\n            let messageResponse;\n            if (doSendMessageRequest) {\n                messageResponse = await doSendMessageRequest(channel, messageData, options);\n            }\n            else {\n                messageResponse = await channel.sendMessage(messageData, options);\n            }\n            let existingMessage;\n            for (let i = channel.state.messages.length - 1; i >= 0; i--) {\n                const msg = channel.state.messages[i];\n                if (msg.id && msg.id === messageData.id) {\n                    existingMessage = msg;\n                    break;\n                }\n            }\n            const responseTimestamp = new Date(messageResponse?.message?.updated_at || 0).getTime();\n            const existingMessageTimestamp = existingMessage?.updated_at?.getTime() || 0;\n            const responseIsTheNewest = responseTimestamp > existingMessageTimestamp;\n            // Replace the message payload after send is completed\n            // We need to check for the newest message payload, because on slow network, the response can arrive later than WS events message.new, message.updated.\n            // Always override existing message in status \"sending\"\n            if (messageResponse?.message &&\n                (responseIsTheNewest || existingMessage?.status === 'sending')) {\n                updateMessage({\n                    ...messageResponse.message,\n                    status: 'received',\n                });\n            }\n            if (quotedMessage && parent_id === quotedMessage?.parent_id)\n                setQuotedMessage(undefined);\n        }\n        catch (error) {\n            // error response isn't usable so needs to be stringified then parsed\n            const stringError = JSON.stringify(error);\n            const parsedError = (stringError\n                ? JSON.parse(stringError)\n                : {});\n            // Handle the case where the message already exists\n            // (typically, when retrying to send a message).\n            // If the message already exists, we can assume it was sent successfully,\n            // so we update the message status to \"received\".\n            // Right now, the only way to check this error is by checking\n            // the combination of the error code and the error description,\n            // since there is no special error code for duplicate messages.\n            if (parsedError.code === 4 &&\n                error instanceof Error &&\n                error.message.includes('already exists')) {\n                updateMessage({\n                    ...message,\n                    status: 'received',\n                });\n            }\n            else {\n                updateMessage({\n                    ...message,\n                    error: parsedError,\n                    errorStatusCode: parsedError.status || undefined,\n                    status: 'failed',\n                });\n                thread?.upsertReplyLocally({\n                    // @ts-expect-error\n                    message: {\n                        ...message,\n                        error: parsedError,\n                        errorStatusCode: parsedError.status || undefined,\n                        status: 'failed',\n                    },\n                });\n            }\n        }\n    };\n    const sendMessage = async ({ attachments = [], mentioned_users = [], parent, text = '', }, customMessageData, options) => {\n        channel.state.filterErrorMessages();\n        const messagePreview = {\n            attachments,\n            created_at: new Date(),\n            html: text,\n            id: customMessageData?.id ?? `${client.userID}-${nanoid()}`,\n            mentioned_users,\n            parent_id: parent?.id,\n            reactions: [],\n            status: 'sending',\n            text,\n            type: 'regular',\n            user: client.user,\n        };\n        thread?.upsertReplyLocally({\n            // @ts-expect-error\n            message: messagePreview,\n        });\n        updateMessage(messagePreview);\n        await doSendMessage(messagePreview, customMessageData, options);\n    };\n    const retrySendMessage = async (message) => {\n        updateMessage({\n            ...message,\n            errorStatusCode: undefined,\n            status: 'sending',\n        });\n        if (message.attachments) {\n            // remove scraped attachments added during the message composition in MessageInput to prevent sync issues\n            message.attachments = message.attachments.filter((attachment) => !attachment.og_scrape_url);\n        }\n        await doSendMessage(message);\n    };\n    const removeMessage = (message) => {\n        channel.state.removeMessage(message);\n        dispatch({\n            channel,\n            parentId: state.thread && message.parent_id,\n            type: 'copyMessagesFromChannel',\n        });\n    };\n    /** THREAD */\n    const openThread = (message, event) => {\n        event?.preventDefault();\n        setQuotedMessage((current) => {\n            if (current?.parent_id !== message?.parent_id) {\n                return undefined;\n            }\n            else {\n                return current;\n            }\n        });\n        dispatch({ channel, message, type: 'openThread' });\n    };\n    const closeThread = (event) => {\n        event?.preventDefault();\n        dispatch({ type: 'closeThread' });\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const loadMoreThreadFinished = useCallback(debounce((threadHasMore, threadMessages) => {\n        dispatch({\n            threadHasMore,\n            threadMessages,\n            type: 'loadMoreThreadFinished',\n        });\n    }, 2000, { leading: true, trailing: true }), []);\n    const loadMoreThread = async (limit = DEFAULT_THREAD_PAGE_SIZE) => {\n        // FIXME: should prevent loading more, if state.thread.reply_count === channel.state.threads[parentID].length\n        if (state.threadLoadingMore || !state.thread || !state.threadHasMore)\n            return;\n        dispatch({ type: 'startLoadingThread' });\n        const parentId = state.thread.id;\n        if (!parentId) {\n            return dispatch({ type: 'closeThread' });\n        }\n        const oldMessages = channel.state.threads[parentId] || [];\n        const oldestMessageId = oldMessages[0]?.id;\n        try {\n            const queryResponse = await channel.getReplies(parentId, {\n                id_lt: oldestMessageId,\n                limit,\n            });\n            const threadHasMoreMessages = hasMoreMessagesProbably(queryResponse.messages.length, limit);\n            const newThreadMessages = channel.state.threads[parentId] || [];\n            // next set loadingMore to false so we can start asking for more data\n            loadMoreThreadFinished(threadHasMoreMessages, newThreadMessages);\n        }\n        catch (e) {\n            loadMoreThreadFinished(false, oldMessages);\n        }\n    };\n    const onMentionsHoverOrClick = useMentionsHandlers(onMentionsHover, onMentionsClick);\n    const editMessage = useEditMessageHandler(doUpdateMessageRequest);\n    const { typing, ...restState } = state;\n    const channelStateContextValue = useCreateChannelStateContext({\n        ...restState,\n        acceptedFiles,\n        channel,\n        channelCapabilitiesArray,\n        channelConfig,\n        channelUnreadUiState,\n        debounceURLEnrichmentMs: enrichURLForPreviewConfig?.debounceURLEnrichmentMs,\n        dragAndDropWindow,\n        enrichURLForPreview: props.enrichURLForPreview,\n        findURLFn: enrichURLForPreviewConfig?.findURLFn,\n        giphyVersion: props.giphyVersion || 'fixed_height',\n        imageAttachmentSizeHandler: props.imageAttachmentSizeHandler || getImageAttachmentConfiguration,\n        maxNumberOfFiles,\n        multipleUploads,\n        mutes,\n        notifications,\n        onLinkPreviewDismissed: enrichURLForPreviewConfig?.onLinkPreviewDismissed,\n        quotedMessage,\n        shouldGenerateVideoThumbnail: props.shouldGenerateVideoThumbnail || true,\n        videoAttachmentSizeHandler: props.videoAttachmentSizeHandler || getVideoAttachmentConfiguration,\n        watcher_count: state.watcherCount,\n    });\n    const channelActionContextValue = useMemo(() => ({\n        addNotification,\n        closeThread,\n        deleteMessage,\n        dispatch,\n        editMessage,\n        jumpToFirstUnreadMessage,\n        jumpToLatestMessage,\n        jumpToMessage,\n        loadMore,\n        loadMoreNewer,\n        loadMoreThread,\n        markRead,\n        onMentionsClick: onMentionsHoverOrClick,\n        onMentionsHover: onMentionsHoverOrClick,\n        openThread,\n        removeMessage,\n        retrySendMessage,\n        sendMessage,\n        setChannelUnreadUiState,\n        setQuotedMessage,\n        skipMessageDataMemoization,\n        updateMessage,\n    }), \n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        channel.cid,\n        deleteMessage,\n        enrichURLForPreviewConfig?.findURLFn,\n        enrichURLForPreviewConfig?.onLinkPreviewDismissed,\n        loadMore,\n        loadMoreNewer,\n        markRead,\n        quotedMessage,\n        jumpToFirstUnreadMessage,\n        jumpToMessage,\n        jumpToLatestMessage,\n        setChannelUnreadUiState,\n    ]);\n    // @ts-expect-error\n    const componentContextValue = useMemo(() => ({\n        Attachment: props.Attachment,\n        AttachmentPreviewList: props.AttachmentPreviewList,\n        AttachmentSelector: props.AttachmentSelector,\n        AttachmentSelectorInitiationButtonContents: props.AttachmentSelectorInitiationButtonContents,\n        AudioRecorder: props.AudioRecorder,\n        AutocompleteSuggestionItem: props.AutocompleteSuggestionItem,\n        AutocompleteSuggestionList: props.AutocompleteSuggestionList,\n        Avatar: props.Avatar,\n        BaseImage: props.BaseImage,\n        CooldownTimer: props.CooldownTimer,\n        CustomMessageActionsList: props.CustomMessageActionsList,\n        DateSeparator: props.DateSeparator,\n        EditMessageInput: props.EditMessageInput,\n        EmojiPicker: props.EmojiPicker,\n        emojiSearchIndex: props.emojiSearchIndex,\n        EmptyStateIndicator: props.EmptyStateIndicator,\n        FileUploadIcon: props.FileUploadIcon,\n        GiphyPreviewMessage: props.GiphyPreviewMessage,\n        HeaderComponent: props.HeaderComponent,\n        Input: props.Input,\n        LinkPreviewList: props.LinkPreviewList,\n        LoadingIndicator: props.LoadingIndicator,\n        Message: props.Message,\n        MessageActions: props.MessageActions,\n        MessageBouncePrompt: props.MessageBouncePrompt,\n        MessageDeleted: props.MessageDeleted,\n        MessageListNotifications: props.MessageListNotifications,\n        MessageNotification: props.MessageNotification,\n        MessageOptions: props.MessageOptions,\n        MessageRepliesCountButton: props.MessageRepliesCountButton,\n        MessageStatus: props.MessageStatus,\n        MessageSystem: props.MessageSystem,\n        MessageTimestamp: props.MessageTimestamp,\n        ModalGallery: props.ModalGallery,\n        PinIndicator: props.PinIndicator,\n        PollActions: props.PollActions,\n        PollContent: props.PollContent,\n        PollCreationDialog: props.PollCreationDialog,\n        PollHeader: props.PollHeader,\n        PollOptionSelector: props.PollOptionSelector,\n        QuotedMessage: props.QuotedMessage,\n        QuotedMessagePreview: props.QuotedMessagePreview,\n        QuotedPoll: props.QuotedPoll,\n        reactionOptions: props.reactionOptions,\n        ReactionSelector: props.ReactionSelector,\n        ReactionsList: props.ReactionsList,\n        SendButton: props.SendButton,\n        StartRecordingAudioButton: props.StartRecordingAudioButton,\n        ThreadHead: props.ThreadHead,\n        ThreadHeader: props.ThreadHeader,\n        ThreadStart: props.ThreadStart,\n        Timestamp: props.Timestamp,\n        TriggerProvider: props.TriggerProvider,\n        TypingIndicator: props.TypingIndicator,\n        UnreadMessagesNotification: props.UnreadMessagesNotification,\n        UnreadMessagesSeparator: props.UnreadMessagesSeparator,\n        VirtualMessage: props.VirtualMessage,\n    }), [\n        props.Attachment,\n        props.AttachmentPreviewList,\n        props.AttachmentSelector,\n        props.AttachmentSelectorInitiationButtonContents,\n        props.AudioRecorder,\n        props.AutocompleteSuggestionItem,\n        props.AutocompleteSuggestionList,\n        props.Avatar,\n        props.BaseImage,\n        props.CooldownTimer,\n        props.CustomMessageActionsList,\n        props.DateSeparator,\n        props.EditMessageInput,\n        props.EmojiPicker,\n        props.EmptyStateIndicator,\n        props.FileUploadIcon,\n        props.GiphyPreviewMessage,\n        props.HeaderComponent,\n        props.Input,\n        props.LinkPreviewList,\n        props.LoadingIndicator,\n        props.Message,\n        props.MessageActions,\n        props.MessageBouncePrompt,\n        props.MessageDeleted,\n        props.MessageListNotifications,\n        props.MessageNotification,\n        props.MessageOptions,\n        props.MessageRepliesCountButton,\n        props.MessageStatus,\n        props.MessageSystem,\n        props.MessageTimestamp,\n        props.ModalGallery,\n        props.PinIndicator,\n        props.PollActions,\n        props.PollContent,\n        props.PollCreationDialog,\n        props.PollHeader,\n        props.PollOptionSelector,\n        props.QuotedMessage,\n        props.QuotedMessagePreview,\n        props.QuotedPoll,\n        props.ReactionSelector,\n        props.ReactionsList,\n        props.SendButton,\n        props.StartRecordingAudioButton,\n        props.ThreadHead,\n        props.ThreadHeader,\n        props.ThreadStart,\n        props.Timestamp,\n        props.TriggerProvider,\n        props.TypingIndicator,\n        props.UnreadMessagesNotification,\n        props.UnreadMessagesSeparator,\n        props.VirtualMessage,\n        props.emojiSearchIndex,\n        props.reactionOptions,\n    ]);\n    const typingContextValue = useCreateTypingContext({\n        typing,\n    });\n    if (state.error) {\n        return (React.createElement(ChannelContainer, null,\n            React.createElement(LoadingErrorIndicator, { error: state.error })));\n    }\n    if (state.loading) {\n        return (React.createElement(ChannelContainer, null,\n            React.createElement(LoadingIndicator, null)));\n    }\n    if (!channel.watch) {\n        return (React.createElement(ChannelContainer, null,\n            React.createElement(\"div\", null, t('Channel Missing'))));\n    }\n    return (React.createElement(ChannelContainer, { className: windowsEmojiClass },\n        React.createElement(ChannelStateProvider, { value: channelStateContextValue },\n            React.createElement(ChannelActionProvider, { value: channelActionContextValue },\n                React.createElement(WithComponents, { overrides: componentContextValue },\n                    React.createElement(TypingProvider, { value: typingContextValue },\n                        React.createElement(\"div\", { className: `${chatContainerClass}` },\n                            dragAndDropWindow && (React.createElement(DropzoneProvider, { ...optionalMessageInputProps }, children)),\n                            !dragAndDropWindow && React.createElement(React.Fragment, null, children))))))));\n};\n/**\n * A wrapper component that provides channel data and renders children.\n * The Channel component provides the following contexts:\n * - [ChannelStateContext](https://getstream.io/chat/docs/sdk/react/contexts/channel_state_context/)\n * - [ChannelActionContext](https://getstream.io/chat/docs/sdk/react/contexts/channel_action_context/)\n * - [ComponentContext](https://getstream.io/chat/docs/sdk/react/contexts/component_context/)\n * - [TypingContext](https://getstream.io/chat/docs/sdk/react/contexts/typing_context/)\n */\nexport const Channel = React.memo(UnMemoizedChannel);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}